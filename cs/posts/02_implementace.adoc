= 02: Implementace {cpp} 
Daniel Langr <daniel.langr@gmail.com>
:revdate: říjen 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: Úkolem implementace {cpp} je na konkrétním počítačovém systému zajistit pro program pozorovatelné chování, které mu podle zdrojového kódu předepisuje Standard {cpp}.

[.normal]
link:../../en/posts/02_implementation.html[English version] image:https://www.countryflags.io/gb/shiny/24.png[English version, link="../../en/posts/02_implementation.html"] +
link:../index.html[Úvodní stránka] image:up.png[link="../index.html"] 

''''

[quote, Bertrand Meyer]
____
There are only two things wrong with {cpp}: The initial concept and the implementation.
____

Jak již bylo řečeno, *implementace {cpp}* zajišťuje aby program spuštěný na konkrétním počítačovém systému měl takové pozorovatelné chování, jaké mu předepisuje standard {cpp} dle jeho zdrojového kódu. Implementace {cpp} obsahuje především *překladač {cpp}*. Pokud nebude uvedeno jinak, budeme pro jednoduchost pod tímto pojmem rozumět celou kolekci nástrojů, která je potřebná pro *vygenerování spustitelného programu či knihovního souboru ze zdrojového kódu*. Mimo vlastního „generátoru“ strojového kódu sem tedy zahrneme i nástroje jako jsou například _preprocesor_ či _linker_.

Překladač pro implementaci {cpp} na konkrétním počítači ale sám o sobě nestačí. Standard {cpp} obsahuje *dvě hlavní části*. Ta první popisuje *vlastní programovací jazyk*, tedy například základní datové typy a operace nad nimi, funkce, třídy, šablony, apod. Druhá a mnohem obsáhlejší část (rozsahem více jak dvojnásobně v současném draftu standardu) se zabývá *standardní knihovnou {cpp}* _({cpp} standard library)_.

.Standardní knihovna {cpp} vs STL
****
{cpp} standardní knihovna je někdy označována pojmem *_STL_*, což je zkratka *_standard template library_*. Někdo zase tento pojem používá pouze pro část standardní knihovny {cpp}, která se zabývá algoritmy, kontejnery a iterátory. Teoreticky je použití pojmu STL *nesprávné* -- ve standardu {cpp} se vůbec neobjevuje. Přesto se v praxi *zažilo a běžně na něj můžeme narazit*. Microsoft například repozitář svoji implementace standardní knihovny {cpp} na GitHubu pojmenovává _microsoft/STL_, Intel svoji paralelní verzi standardní knihovny {cpp} zase nazývá _Parallel STL_.

****

Zjednodušeně se dá říct, že první část standardu obsahuje vše, co je potřeba k napsání zdrojového kódu, který *nevyužívá* žádný *hlavičkový soubor standardní knihovny {cpp}*. (Existují výjimky -- například se v této části popisuje alokační funkce `::operator new`, která je poskytovaná hlavičkovým souborem `<new>`.) Příklad takového kódu je následující:

[source]
----
int main()
{
  return 1;
}
----

K vygenerování binárního spustitelného programu z tohoto zdrojového kódu stačí překladač {cpp} sám o sobě. To ale už nebude platit o následujícím zdrojovém kódu:

[source]
----
#include <iostream>

int main()
{
  std::cout << 1;
}
----

Pro vygenerování spustitelného programu a případně i pro jeho spuštění (v případě dynamického linkování) je zde navíc potřeba ještě *implementace standardní knihovny {cpp}*. V praxi *nejpoužívanější implementace* jsou -- alespoň pro architekturu x86_64 -- _libstdc{plus}{plus}_ od _GNU_, _libc{plus}{plus}_ od _LLVM_, a již zmíněná _Microsoft STL_.

Některé překladače mohou spolupracovat s různými implementacemi standardní knihovny -- například překladač _Clang_ umí používat  _libstdc{plus}{plus}_ i s _libc{plus}{plus}_. To, jaká knihovna bude použitá implicitně je dáno instalací a systémem. Na Linuxu _Clang_ většinou implicitně použije _libstdc{plus}{plus}_, zatímco na Mac OS X to bude _libc{plus}{plus}_. Většina překladačů je ale poměrně *těsně svázána* s konkrétní implementaci standardní knihovny. Pro příklad, překladače od GNU (GCC) a Intelu využívají _libstdc{plus}{plus}_, překladač Microsfotu samozřejmě _Microsoft STL_.

Velkou část standardní knihovny {cpp} představují *šablony*. Jejich zdrojový kód musí být pro překladač „viditelný“ při překladu a proto ho lze u implementací najít ve formě *hlavičkových souborů*. *Kompletní zdrojový kód* zmíněných implementací je navíc dostupný i formou *repozitářů na GitHubu*, konkrétně:

- _libstdc{plus}{plus}_: repozitář _gcc-mirror/gcc_ -- podadresář link:https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3[_libstdc{plus}{plus}-v3_],
- _libc{plus}{plus}_: repozitář _llvm/llvm-project_ -- podadresář link:https://github.com/llvm/llvm-project/tree/master/libcxx[_libcxx_],
- _Microsoft STL_: repozitář link:https://github.com/microsoft/STL[_microsoft/STL_].

Zdrojový kód může být vynikajícím *materiálem pro učení {cpp}*. Výše zmíněné implementace jsou vyvíjené se zaměřením na vysoký výkon a zároveň jsou v praxi dennodenně testované a ověřované vysokým množstvím programátorů a jejich programů. Na druhou stranu je tento kód velmi rozsáhlý a může být obtížné se v něm na první pohled zorientovat.

Studium zdrojového kódu může být také užitečné, pokud chceme pochopit, proč se implementace *chová nějakým konkrétním způsobem*. Pro příklad -- všechny tři zmíněné implementace standardní knihovny {cpp} aplikují pro třídu `std::string` optimalizační techniku *_small (short) string optimization_ (SSO)*. Ta zajišťuje, že pro řetězce *do určité délky* není potřeba dynamická alokace paměti. Místo toho je řetězec znaků uložen *v rámci bitové reprezentace objektu třídy*.

Limit pro délku „krátkého“ řetězce závisí na tom, *jakým způsobem* je SSO implementováno. Tento limit můžeme zjistit vypsáním *kapacity* prázdného objektu třídy. Zároveň se podívejme i na *velikost jeho bitové reprezentace* zjistitelné pomocí operátoru `sizeof`:

[source]
----
#include <iostream>
#include <string>

int main()
{
  std::string s;
  std::cout << s.capacity() << std::endl;
  std::cout << sizeof s << std::endl;
}
----

Já jsem na architektuře X86_64 obdržel u _libstdc{plus}{plus}_ a _Microsoft STL_ shodně *kapacitu 15 a velikost 32*, kdežto u _libc{plus}{plus}_ *kapacitu 22 a velikost 24*. Zdánlivě je tedy _libc{plus}{plus}_ výrazně efektivnější -- do 24 bytů je schopna bez dynamické alokace uložit řetězec až o 22 znacích, kdežto ostatní dvě implementace do 32 bytů uloží maximálně 15 jen znaků.

Pro pochopení rozdílu mezi implementovanými variantami SSO je nutné podívat se do zdrojového kódu. Detailní analýza je mimo rozsah tohoto tématu (snad se k ní dostaneme v budoucnu v samostatném článku), ale ve stručnosti se dá říct, že _libc{plus}{plus}_ *preferuje vysokou paměťovou efektivitu na úkor té časové*. Musí totiž při každém přístupu k uloženému řetězci znaků nejprve zjistit, zda je krátký (do 22 znaků) či dlouhý, a podle toho *odvodit ukazatel na uložené znaky*. To představuje určitou *časovou režii*. Oproti tomu, u _libstdc{plus}{plus}_ a _Microsoft STL_ má objekt třídy `std::string` ukazatel na znaky řetězce přímo uložený ve formě *samostatné členské proměnné*. To sice snižuje paměťovou efektivitu, ale zase zvyšuje tu časovou.

Jiným příkladem pro studium zdrojového kódu implementací standardní knihovny {cpp} může být následující problém (tento příklad je spíše *pro pokročilé* -- pokud mu neporozumíte, nedělejte si s tím hlavu a prostě ho přeskočte):

[source]
----
#include <map>
#include <thread>
#include <vector>

int main()
{
  std::vector< std::map<int, std::thread> > v;
  v.reserve(1);
}
----

V mém případě tento kód bez problému přeložily implementace používající _libstdc{plus}{plus}_ i _libc{plus}{plus}_. Překlad s _Microsoft STL_ ale *skončil s chybou*. Proč tomu tak je? Ze zdrojového kódu lze zjistit, že u _libstdc{plus}{plus}_ i _libc{plus}{plus}_ *přesouvací konstruktor* _(move constructor)_ typu `std::map<int, std::thread>` *nemůže vyhodit výjimku* -- „je“ tzv. _noexcept_ (správně bychom měli říkat, že tento konstruktor má „nevyhazující specifikaci výjimky“ -- _non-throwing exception specification_). V implementaci _Microsoft STL_ to ale *neplatí*.

Přesouvací konstruktory vyhazující výjimky jsou obecně *problematické*. V případě „realokační“ členské funkce `reserve` u vektoru může takové vyhození výjimky způsobit, že obsah vektoru bude po volání funkce *jiný* než jaký byl před tímto voláním (nebude splněna tzv. _strong exception guarantee_). Standard {cpp} proto předepisuje, že členská funkce `reserve` má v takovém případě *dát přednost kopírovacímu konstruktoru*.

Posledním kouskem skládačky je fakt, že objekty třídy `std::thread` jsou *nekopírovatelné*. To samozřejmě znamená, že nelze zkopírovat ani obsah libovolného kontejneru, který objekty této třídy obsahuje. V našem případě je to mapa `std::map<int, std::thread>`. U _Microsoft STL_ se tedy členská funkce vektoru `reserve` snaží volat kopírovací konstruktor této mapy, což při překladu selže na nemožnosti kopírování uložených objektů typu `std::thread`.

.Která implementace je ta správná?
****
V popsaném případě se implementace *chovají rozdílně*, a to dokonce na úrovni úspěšného/neúspěšného překladu stejného zdrojového kódu. Která implementace je tedy ta správná? Odpověď je, že *všechny tři*. Standard {cpp} totiž *nepožaduje*, aby přesouvací konstruktor třídní šablony `std::map` byl _noexcept_. Na druhou stranu to ale ani *nezakazuje*.
****

.Souhrn
****
- *Implementace {cpp}* zajišťuje aby program spuštěný na *konkrétním počítačovém systému* měl takové *pozorovatelné chování*, jaké mu předepisuje standard {cpp} *dle jeho zdrojového kódu*.
- Obsahuje sadu nástrojů pro *překlad* zdrojového kódu na spustitelný strojový kód (preprocesor, překladač, linker, apod.) a dále *implementaci standardní knihovny {cpp}*.
- *Nejčastěji používané implementace* standardní knihovny {cpp} jsou _libstdc{plus}{plus}_, _libc{plus}{plus}_, a _Microsoft STL_. Jejich zdrojový kód je ve všech třech případech *volně dostupný*.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
