= 01: _As-if_ pravidlo
Daniel Langr <daniel.langr@gmail.com>
//:revdate: {docdate}
:revdate: říjen 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: Úkolem implementace {cpp} je u programu zajistit pozorovatelné chování, které mu podle zdrojového kódu předepisuje Standard {cpp}.

[.normal]
link:../index.html[Úvodní stránka] image:up.png[link="../index.html"] +
//link:../../en/posts/01_asif.html[English version] image:https://www.countryflags.io/gb/shiny/24.png[English, link="../../en/posts/01_asif.html"]

''''

//"`__Every time I write a line of code in {cpp} I check the assembly output to make sure it's running at optimal speed. I profile everything and also I have no friends.__`" _[Cole Rowland]_
[quote, Cole Rowland]
____
Every time I write a line of code in {cpp} I check the assembly output to make sure it's running at optimal speed. I profile everything and also I have no friends.
____

{cpp} je tzv. „kompilovaný jazyk“ _(compiled language)_, tj. programovací jazyk fungující na principu *překladu zdrojového kódu na strojový kód*. Nejjednodušší zdrojový kód programu vypadá v {cpp} následovně:

.main.cpp
[source]
----
int main() { }
----

Jeho překladem pomocí {cpp} překladače, například tímto způsobem:

[source,bash]
----
g++ main.cpp
----

vznikne *program* spustitelný na daném počítačovém systému. Spuštěním tohoto programu se vytvoří jeho běžící instance -- *proces* operačního systému. Ten začne vykonávat překladačem vygenerovaný strojový kód, tedy *instrukce procesoru*. V mém případě architektury x86_64 a operačního systému Linux měly následující podobu:

[source,x86asm]
----
push rbp
mov  rbp, rsp
mov  eax, 0
pop  rbp
ret
----

.Strojový kód vs assembler
****
Strojový kód ve skutečnosti představují prakticky nečitelná *binární data*. Pro jeho zkoumání se proto většinou převádí do příslušných *instrukcí assembleru*, k čemuž slouží nástroj zvaný _disassembler_. Příkladem takového nástroje je program `objdump` spuštěný s přepínačem `-d`/`--disassemble`.

Neocenitelným pomocníkem při zkoumání strojového kódu vygenerovaného pro určitý zdrojový kód je *online* {cpp} překladač a _disassembler_ link:https://godbolt.org/[Compiler Explorer]. Je v něm na výběr velké množství *překldačů {cpp}* od různých poskytovatelů a rovněž několik cílových *architektur procesoru*. 
****

Chování programu definuje podle jeho zdrojového kódu *standard {cpp}*. Otázkou je, co si vlastně pod pojmem *chováním programu* představit. Jednoduše řečeno je to *pozorovatelný efekt programu* z pohledu jeho okolí.

Co o chování našeho programu říká standard {cpp}? Od {cpp}11 je opuštění funkce `main` mimo příkaz `return` ekvivaletní spuštění příkazu `return 0;`. Ten způsobí *normální ukončení programu s návratovým statusem 0*, což představuje jediný pozorovatelný efekt tohoto programu. 

{cpp} standard definuje chování programu na *abstraktním počítači*. Na *konkrétním počítačovém systému* toto chování zajišťuje tzv. *implementace {cpp}* (například v našem případě reprezentovaná překladačem `g++`). Jedním z nejdůležitějších konceptů {cpp} je tzv. *_as-if_ pravidlo* _(as-if rule)_. To říká, že {cpp} implementace musí zajisit pouze pozorovatelné chování programu definované pro jeho zdrojový kód, ale *jak* tohoto chování docílí nechává zcela na ní. Implemetnace se poté v rámci optimalizací snaží zajistit pozorovatelné chování programu s ohledem na co *nejvyšší výkon a efektivitu*.

.Efektivní vs efektivní
****
Výraz „efektivní“ má *dva odlišné významy*. První znamená, že nějaká operace *má určitý efekt* -- například, že výpočet vede ke správnému výsledku. To ale ještě neznamená, že tento výpočet bude efektivní *ve smyslu spotřebovaných prostředků systému*. Angličtina tyto významy rozlišuje samostatnými slovíčky _effective_ a _efficient_. V češtině nám nezbývá než význam rozlišit podle *aktuálního kontextu* výkladu.
****

Výše ukázaný překlad proběhl s *vypnutými optimalizacemi*. Proto se ve vygenerovaném strojovém kódu objevily instrukce, které pozorovatelnému efektu programu nijak nepřispívají. Konkréntě to jsou instrukce pracující s registry zásobníku `rbp` a `rsp`. V případě překladu se *zapnutými optimalizacemi*:

[source,bash]
----
g++ -O2 main.cpp
----

se vygenerovaný strojový kód změnil na:

[source,x86asm]
----
xor  eax, eax
ret
----

Ten totiž pozorovatelné chování programu -- normální ukončení programu s návratovým statusem 0 -- zajišťuje *nejúspornějším způsobem*. Na použitém počítačovém systému je totiž návratový status programu předán z funkce `main` v registru `eax`.

.Proč je instrukce `xor eax, eax` efektivnější než `mov eax, 0`?
****
//*Proč je instrukce `xor eax, eax` efektivnější než `mov eax, 0`?*

Binární podoba strojového kódu -- tzv. operační kód _(opcode)_ -- instrukcí `mov eax, 0` a `xor eax, eax` je totiž `b8 00 00 00 00` a `32 c0`, v uvedeném pořadí. U druhé instrukce je tedy výrazně *kratší*. To v praxi šetří množství přenesených dat mezi oprační pamětí a procesorem a zvyšuje efektivitu práce s instrukční cache pamětí.
****

Pokud nyní přepíšeme zdrojový soubor na:

.main1.cpp
[source]
----
int main()
{
  return 1;
}
----

tak překladač již vygeneruje instrukci `mov`:

[source,x86asm]
----
mov eax, 1
ret
----

Naprosto stejně dopadl vygenerovaný strojový kód pro následující zdrojový soubor:

.main2.cpp
[source]
----
int main()
{
  int i = 0;
  i++;
  return i;
}
----

A stejně tak pro:

.main3.cpp
[source]
----
class Int 
{
  int i_;
public:
  Int(int i) : i_(i) { }
  operator int&() { return i_; }
};

int main()
{
  Int i(0);
  i++;
  return i;
}
----

Pozorovatelné chování programu které standard předepisuje pro všechny tři zdrojové soubory `main1.cpp`, `main2.cpp` i `main3.cpp` je totiž *totožné*. To má mimo jiné důsledek, že obecně z přeloženého strojového kódu samotného *nelze zjistit*, z jakého zdrojového kódu byl vytvořen. Dokonce se zapnutými optimalizacemi ani neexistuje přímá korespondece mezi konkrétními příkazy zdrojového kódu a vygenerovanými instrukcemi (pro takové účely je nutné vypnout optimalizace a přidat ladící informace).

Co přesně tvoří pozorovatelný efekt programu *nemusí být vždy úplně jasné*. Vezměme v úvahu následující zdrojový kód:

[source]
----
int main()
{
  int* pi = new int(0);
  delete pi;
}
----

*Zdánlivě* má tento program stejné pozorovatelné chování jako `main.cpp`, tedy pouze ukončení programu s návratovým statusem 0. Na druhou stranu zde dochází k dynamické alokaci paměti a ta může být z okolí programu rovněž *pozorovatelná*, např. pomocí profilovacích nástorjů haldy jako jsou _Valgrind_ nebo _Heaptrack_. O tom, zda mohou být dynamické alokace eliminovány v rámci optimalizací se vedly a vedou diskuze. Novější implementace tuto eliminaci umožňují -- například `g++` se tímto způsobem v mých experimentech chovalo od verze 10. Starší verze vygenerovaly strojový kód s volání funckí pro alokaci a dealokaci paměti.
 
.Benchmarky
****
_As-if_ pravidlo je důležité pro psaní *_benchmarků_*, tj. programů, kde se snažíme *změřit dobu běhu nějaké operace*. V takovém případě je nutné zajistit, aby tato opearce měla pozorovatelný efekt, jinak ji překladač může v rámci optimalizací eliminovat a benchmark poté bude dávat irelevantní výsledky. Například ve frameworku _Google/Benchmark_ je tento problém adresován funkcí `benchmark::DoNotOptimize`.
****

.Souhrn
****
- {cpp} funguje na základě *překladu zdrojového kódu na strojový kód procesoru*.
- Implementace {cpp} zajišťuje, aby vygenerovaný strojový kód na daném počítači měl *stejné pozorovatelné chování*, které mu podle zdrojového kódu předepisuje Stadnard {cpp}.
- Překladače se v rámci optimalizací snaží vygenerovat *co nejefektivnější strojvý kód*, které toto chování zajistí.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
