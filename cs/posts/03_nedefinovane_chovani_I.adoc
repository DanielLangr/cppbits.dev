= 03: Nedefinované chování I.
Daniel Langr <daniel.langr@gmail.com>
:revdate: říjen 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: Pokud nejsou dodržena pravidla standardu {cpp}, chování implementace není definováno.

[.normal]
link:../../en/posts/03_undefined_behavior_I.html[English version] image:https://www.countryflags.io/gb/shiny/24.png[English version, link="../../en/posts/03_undefined_behavior_I.html"] +
link:../index.html[Úvodní stránka] image:up.png[link="../index.html"] 

''''

[quote, Bob Gray]
____
Writing in C or {cpp} is like running a chain saw with all the safety guards removed.
____

Jak již bylo řečeno, standard {cpp} definuje jak se má program chovat na abstraktním počítači na základě zdrojového kódu, ze kterého byl vygenerován. Implementace {cpp} poté zajistí, aby stejné pozorovatelné chování měl i program na konkrétním počítačovém systému.

Standard {cpp} ale nedefinuje chování programu *za všech okolností*. Definuje ho pouze v případě, že jsou *dodržena v něm obsažená pravidla*. Pokud tomu tak není, chování programu standard nedefinuje. Takový případ se označuje pojmem *nedefinované chování* _(undefined behavior_ -- zkráceně _UB)_. 

Nedefinované chování se netýká jen *doby běhu programu* _(runtime)_. Pokud nejsou dodržena pravidla standardu, které se týkají *překladu zdrojového kódu*, standard nedefinuje chování implementace ani v *době překladu* _(compile time)_. Obecně se tedy dá říct, že při nedefinovaném chování, tj. nedodržení pravidel standardu {cpp}, se implementace {cpp} může *chovat libovolným způsobem*. A to v době překladu zdrojového kódu i v době běhu vygenerovaného programu (v případě, že byl vůbec vygenerován).

Příkladem konkrétního pravidla standardu je, že u *celočíselných typů se znaménkem* _(signed)_ nesmí dojít k *přetečení* _(overflow)_. Z takového přetečení tedy vyplývá nedefinované chování:

.main.cpp
[source]
----
#include <limits>

int main()
{
  int i = std::numeric_limits<int>::max();
  i++;
  return i;
}
----

Tento zdrojový kód může vést na nedefinované chování *již v čase překladu*. V rámci optimalizací totiž problematický inkrement může vyhodnocovat překladač. Oproti tomu následující zdrojový kód:

[source]
----
#include <iostream>
#include <limits>

int main()
{
  int i;
  std::cin >> i;
  i++;
  return i;
}
----

způsobí přetečení a tedy nedefinované chování pouze pokud je ze standardního vstupu přečtena maximální hodnota typu `int`. Porušení pravidel standardu zde tedy nemůže nastat dříve než *v čase běhu programu*.

Velmi často kladenou otázkou je, *co se ve skutečnosti stane*, pokud chování není definované. Vraťme se ke zdrojovému kódu `main.cpp`. V mém případě jeho překlad pomocí `g++ -O2 main.cpp` vygeneroval následující instrukce strojového kódu:

[source,x86asm]
----
mov eax, -2147483648
ret
----

Je chování tohoto programu *na úrovni strojového kódu* nedefinované? V žádném případě. Instrukce zcela jasně *jeho chování definují* -- jedná se o normální ukončení programu s návratovým statusem -2147483648. Program tedy definované chování má, ale to bylo v tomto případě *definované implementací*. Z perspektivy standardu {cpp} zůstává chování nadále nedefinované. 

.Nedefinované chování a přenositelnost
****
Z nedefinovaného chování na úrovni standardu {cpp} vyplývá *nepřenositelnost příslušného zdrojového kódu*. Chování programu sice může dodatečně definovat implementace {cpp}, ale není předepsáno standardem jaké by to chování mělo být. Různé implementace tudíž mohou vygenerovat program se *zcela odlišným chováním*.
****

Podívejme se na jiný příklad:

.main2.cpp
[source]
----
int main()
{
  float f = 0.0f;
  int* pi = reinterpret_cast<int*>(&f);
  return *pi;
}
----

`reinterpret_cast` nám umožňuje, abychom se na *bitovou reprezentaci* objektu nějakého typu podívali jako by to byla bitová reprezentace objektu *jiného typu*. V našem případě chceme zjistit, jaká je hodnota objektu typu `int`, který má *stejnou bitovou reprezentaci* jako má objekt typu `float` s nulovou hodnotou. 

Problémem našeho kódu však je, že standard {cpp} dovoluje použít `reinterpret_cast` jen ve *velmi malém a specifickém počtu případů*, mezi které ten náš *nepatří*. Díky tomu dochází na úrovni standardu opět na nedefinované chování. Jak se zachová implementace? Já jsem v případě překladu pomocí `g++ -O2 main2.cpp` obdržel program s těmito instrukcemi:

[source,x86asm]
----
xor eax, eax
ret
----

Jeho chování je samozřejmě opět zcela přesně definované (normální ukončení programu s návratovým statusem 0).

Otázkou zůstává, zda je zde *zaručeno*, že se vygenerovaný program bude chovat tímto způsobem. Standard {cpp} to samozřejmě nezaručuje. Implementace to zaručovat *může, ale také nemusí*, a přesnou odpověď může být velmi komplikované až takřka nemožné zjistit. Dobrou zprávou je, že se implementace většinou (ne-li vždy) chovají *deterministicky*. Je tedy velmi pravděpodobné, že v našem případě vygeneruje překladač `g++` spustitelný soubor s uvedeným chováním vždy při dodržení stejné konfigurace překladu.

V některých případech dokonce implementace {cpp} *explicitně* definuje chování programu, které by podle standardu samotného bylo nedefinované. Příkladem může být stejný problém -- náhled na bitovou reprezentaci objektu jednoho typu přes objekt jiného typu -- ale tentokrát řešený pomocí třídního typu `union`. Ten na rozdíl od třídních typů `class` a `struct` ukládá své členské proměnné v paměti *nikoliv za sebou, ale přes sebe*. Alternativní řešení problému z kódu `main2.cpp` by tedy mohlo vypadat následovně:

.main3.cpp
[source]
----
union U
{
  float f;
  int i;
};

int main()
{
  U u;
  u.f = 0.0f;
  return u.i;
}
----

Členské proměnné `f` a `i` objektu `u` jsou zde uloženy *na stejné adrese*, tj. v paměti se jejich bitové reprezentace *překrývají*. Zápisem hodnoty do jedné proměnné a čtením druhé tedy zdánlivě vyřešíme zadanou úlohu.

Standard {cpp} ale takovéto použití třídního typu `union` *neumožňuje*. Podle pravidel standardu je totiž u objektu typu `union` možné *číst jen tu tzv. _aktivní_ členskou proměnnou*, což je ta, která byla *naposledy zapsána*. V našem případě toto pravidlo splněno není, protože po zápisu do `u.f` dojde ke čtení neaktivní `u.i`.

Přesto překlad pomocí `g++ -O2 main3.cpp` opět vedl na program s definovaných chováním na úrovni instrukcí procesoru:

[source,x86asm]
----
xor eax, eax
ret
----

V tomto případě bylo ale chování vygenerovaného programu *explicitně zaručeno implementací*. GCC totiž ve své dokumentaci deklaruje, že definuje chování i při *čtení neaktivní členské proměnné* objektu typu `union` (viz např. link:https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type-punning[]). Jedná se tedy o *„nadstandardní“ rozšíření jazyka {cpp}*.

Jako jiným případ nedefinovaného chování, které je *„tolerováno“ v praxi*, může sloužit snaha o implementaci kontejneru `std::vector<T>` ze standardní knihovny {cpp} (tento případ je spíše pro pokročilé). Vektor představuje dynamické pole prvků typu `T`. Z důvodu efektivity má objekt vektoru *alokovanou paměť pro určité množství prvků*, ale počet aktuálně uložených prvků může být i menší. (Tento koncept zaručuje *amortizovanou konstantní složitost* často používané operace *přidání prvku na konec vektoru*.)

Předpokládejme, že na alokovanou paměť ukazuje členská proměnná vektoru `data_` typu `T*`. Alokace paměti pro uložení `n` prvků by pak mohla vypadat následovně:

[source]
----
data_ = (T*)::operator new(n * sizeof(T));
----

.Alokátory a alokační funkce
****
`std::vector` provádí ve skutečnosti alokaci *pomocí alokátoru*, jehož typ představuje jeho druhý šablonový argument. *Výchozí hodnota* typu alokátoru pro `std::vector<T>` je `std::allocator<T>`. Alokace pomocí tohoto typu alokátoru je *efektivně ekvivalentní* s výše zmíněnou alokací pomocí operátoru `new`.

`::operator new` představuje *alokační funkci {cpp}* určenou pro dynamickou alokaci bloku *neinicializované paměti* o požadovaném počtu bytů. Pokud s touto funkcí nejste obeznámeni, můžete si místo ní pro účely tohoto článku zjednodušeně představit volání funkce `malloc`.
****

V alokovaném bloku paměti, na který ukazuje ukazatel `data_`, jsou následně *na určitých místech vytvářeny prvky vektoru* -- objekty typu `T` (jak je to zajištěno si povíme někdy v budoucnu). Pro *přístup k prvkům vektoru* je dále definován členský *operátor indexace*, typicky následujícím způsobem:

[source]
----
T& operator[](size_type n) { return data_ + n; }
----

A zde nastává problém. Tento operátor totiž obsahuje *aritmetickou operaci nad ukazatelem* _(pointer arithmetic)_ typu `T*`. Takovou operaci standard {cpp} povoluje nad *polem objektů typu `T`*. My ale máme *blok neinicializované paměti*, ve které byly následně *na jistých místech vytvořeny objekty typu `T`*. A to podle standardu *není pole typu `T`*. Aritmetika s ukazatelem v takovém případě vede na nedefinované chování.

.Je `std::vector` implementovatelný?
****
Dostali jsme se do *paradoxní situace* -- standard předepisuje, jak se má vektor chovat, ale zároveň snaha o jeho implementaci *prakticky nevyhnutelně vede na nedefinované chování*. Na toto téma se vedly a vedou rozsáhlé diskuze. Dobrou zprávou je, že implementace {cpp} o tomto problému dobře ví a *správné chování vektoru zajišťují i nad rámec standardu*.

Uvedenou problematiku adresuje _proposal_ dokumentu P0593R6, dostupný například zde: link:http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0593r6.html[]. Tento _proposal_ by měl být součástí standardu *{cpp}20* (v době psaní tohoto článku dosud oficiálně nevydaného).
****

.Souhrn
****
- K nedefinovanému chování vede *nedodržení pravidel standardu {cpp}*.
- Při nedefinovaném chování standard *nepředepisuje*, jak se má implementace {cpp} pro daný zdrojový kód chovat. Ta se poté může chovat *libovolným způsobem*, a to v *čase překladu* i v *čase běhu programu*.
- Implementace se v takových případech obecně *chovají deterministicky*. Obvykle vygenerují program, jehož chování je *definované jeho strojovým kódem*.
- Nedefinované chování obecně vede na *nepřenositelný zdrojový kód* -- ve smyslu, že se pro něj *různé implementace* mohou chovat *odlišným způsobem*.
- V některých případech implementace {cpp} *explicitně definuje chování*, i když podle standardu definované není.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
