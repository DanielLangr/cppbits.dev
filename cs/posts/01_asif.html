<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="Program musí zajistit pouze pozorovatelné chování, které je mu předepsáno podle jeho zdrojového kódu.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../../favicon/favicon.png">
<title>01: As-if pravidlo</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>01: <em>As-if</em> pravidlo</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">říjen 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../../en/posts/01_asif.html">English version</a> <span class="image"><a class="image" href="../../en/posts/01_asif.html"><img src="https://www.countryflags.io/gb/shiny/24.png" alt="English version"></a></span><br>
<a href="../index.html">Úvodní stránka</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Every time I write a line of code in C&#43;&#43; I check the assembly output to make sure it&#8217;s running at optimal speed. I profile everything and also I have no friends.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Cole Rowland
</div>
</div>
<div class="paragraph">
<p>C&#43;&#43; je tzv. „kompilovaný jazyk“ <em>(compiled language)</em>, tj. programovací jazyk fungující na principu <strong>překladu zdrojového kódu na strojový kód</strong>. Nejjednodušší zdrojový kód programu vypadá v C&#43;&#43; následovně:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main() { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeho překladem pomocí C&#43;&#43; překladače, například tímto způsobem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">g++ main.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>vznikne <strong>program</strong> spustitelný na daném počítačovém systému. Spuštěním tohoto programu se vytvoří jeho běžící instance&#8201;&#8212;&#8201;<strong>proces</strong> operačního systému. Ten začne vykonávat překladačem vygenerovaný strojový kód, tedy <strong>instrukce procesoru</strong>. V mém případě architektury x86_64 a operačního systému Linux měly následující podobu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">push rbp
mov  rbp, rsp
mov  eax, 0
pop  rbp
ret</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Strojový kód vs assembler</div>
<div class="paragraph">
<p>Strojový kód ve skutečnosti představují prakticky nečitelná <strong>binární data</strong>. Pro jeho zkoumání se proto většinou převádí do příslušných <strong>instrukcí assembleru</strong>, k čemuž slouží nástroj zvaný <em>disassembler</em>. Příkladem takového nástroje je program <code>objdump</code> spuštěný s přepínačem <code>-d</code>/<code>--disassemble</code>.</p>
</div>
<div class="paragraph">
<p>Neocenitelným pomocníkem při zkoumání strojového kódu vygenerovaného pro určitý zdrojový kód je <strong>online</strong> C&#43;&#43; překladač a <em>disassembler</em> <a href="https://godbolt.org/">Compiler Explorer</a>. Je v něm na výběr velké množství <strong>překladačů C&#43;&#43;</strong> od různých poskytovatelů a rovněž několik cílových <strong>architektur procesoru</strong>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Chování programu definuje podle jeho zdrojového kódu <strong>standard C&#43;&#43;</strong>. Otázkou je, co si vlastně pod pojmem <strong>chováním programu</strong> představit. Jednoduše řečeno je to <strong>pozorovatelný efekt programu</strong> z pohledu jeho okolí.</p>
</div>
<div class="paragraph">
<p>Co o chování našeho programu říká standard C&#43;&#43;? Od C&#43;&#43;11 je opuštění funkce <code>main</code> mimo příkaz <code>return</code> ekvivalentní spuštění příkazu <code>return 0;</code>. Ten způsobí <strong>normální ukončení programu s návratovým statusem 0</strong>, což představuje jediný pozorovatelný efekt tohoto programu.</p>
</div>
<div class="paragraph">
<p>C&#43;&#43; standard definuje chování programu na <strong>abstraktním počítači</strong>. Na <strong>konkrétním počítačovém systému</strong> toto chování zajišťuje <strong>implementace C&#43;&#43;</strong> (například v našem případě reprezentovaná překladačem <code>g++</code>). Jedním z nejdůležitějších konceptů C&#43;&#43; je tzv. <strong><em>as-if</em> pravidlo</strong> <em>(as-if rule)</em>. To říká, že C&#43;&#43; implementace musí zajistit pouze pozorovatelné chování programu definované pro jeho zdrojový kód, ale <strong>jak</strong> tohoto chování docílí nechává zcela na ní. Implementace se poté v rámci optimalizací snaží zajistit pozorovatelné chování programu s ohledem na co <strong>nejvyšší výkon a efektivitu</strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Efektivní vs efektivní</div>
<div class="paragraph">
<p>Výraz „efektivní“ má <strong>dva odlišné významy</strong>. První znamená, že nějaká operace <strong>má určitý efekt</strong>&#8201;&#8212;&#8201;například, že výpočet vede ke správnému výsledku. To ale ještě neznamená, že tento výpočet bude efektivní <strong>ve smyslu spotřebovaných prostředků systému</strong>. Angličtina tyto významy rozlišuje samostatnými slovíčky <em>effective</em> a <em>efficient</em>. V češtině nám nezbývá než význam rozlišit podle <strong>aktuálního kontextu</strong> výkladu.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Výše ukázaný překlad proběhl s <strong>vypnutými optimalizacemi</strong>. Proto se ve vygenerovaném strojovém kódu objevily instrukce, které pozorovatelnému efektu programu nijak nepřispívají. Konkrétně to jsou instrukce pracující s registry zásobníku <code>rbp</code> a <code>rsp</code>. V případě překladu se <strong>zapnutými optimalizacemi</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">g++ -O2 main.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>se vygenerovaný strojový kód změnil na:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">xor  eax, eax
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ten totiž pozorovatelné chování programu&#8201;&#8212;&#8201;normální ukončení programu s návratovým statusem 0&#8201;&#8212;&#8201;zajišťuje <strong>nejúspornějším způsobem</strong>. Na použitém počítačovém systému je totiž návratový status programu předán z funkce <code>main</code> v registru <code>eax</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Proč je instrukce <code>xor eax, eax</code> efektivnější než <code>mov eax, 0</code>?</div>
<div class="paragraph">
<p>Binární podoba strojového kódu&#8201;&#8212;&#8201;tzv. operační kód <em>(opcode)</em>&#8201;&#8212;&#8201;instrukcí <code>mov eax, 0</code> a <code>xor eax, eax</code> je totiž <code>b8 00 00 00 00</code> a <code>32 c0</code>, v uvedeném pořadí. U druhé instrukce je tedy výrazně <strong>kratší</strong>. To v praxi šetří množství přenesených dat mezi operační pamětí a procesorem a zvyšuje efektivitu práce s instrukční cache pamětí.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Pokud nyní přepíšeme zdrojový soubor na:</p>
</div>
<div class="listingblock">
<div class="title">main1.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  return 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>tak překladač již vygeneruje instrukci <code>mov</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">mov eax, 1
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Naprosto stejně dopadl vygenerovaný strojový kód pro následující zdrojový soubor:</p>
</div>
<div class="listingblock">
<div class="title">main2.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  int i = 0;
  i++;
  return i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A stejně tak pro:</p>
</div>
<div class="listingblock">
<div class="title">main3.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">class Int
{
  int i_;
public:
  Int(int i) : i_(i) { }
  operator int&amp;() { return i_; }
};

int main()
{
  Int i(0);
  i++;
  return i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pozorovatelné chování programu které standard předepisuje pro všechny tři zdrojové soubory <code>main1.cpp</code>, <code>main2.cpp</code> i <code>main3.cpp</code> je totiž <strong>totožné</strong>. To má mimo jiné důsledek, že obecně z přeloženého strojového kódu samotného <strong>nelze zjistit</strong>, z jakého zdrojového kódu byl vytvořen. Dokonce se zapnutými optimalizacemi ani neexistuje přímá korespondence mezi konkrétními příkazy zdrojového kódu a vygenerovanými instrukcemi (pro takové účely je nutné vypnout optimalizace a přidat ladící informace).</p>
</div>
<div class="paragraph">
<p>Co přesně tvoří pozorovatelný efekt programu <strong>nemusí být vždy úplně jasné</strong>. Vezměme v úvahu následující zdrojový kód:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  int* pi = new int(0);
  delete pi;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Zdánlivě</strong> má tento program stejné pozorovatelné chování jako <code>main.cpp</code>, tedy pouze ukončení programu s návratovým statusem 0. Na druhou stranu zde dochází k dynamické alokaci paměti a ta může být z okolí programu rovněž <strong>pozorovatelná</strong>, např. pomocí profilovacích nástorjů haldy jako jsou <em>Valgrind</em> nebo <em>Heaptrack</em>. O tom, zda mohou být dynamické alokace eliminovány v rámci optimalizací se vedly a vedou diskuze. Novější implementace tuto eliminaci umožňují&#8201;&#8212;&#8201;například <code>g++</code> se tímto způsobem v mých experimentech chovalo od verze 10. Starší verze vygenerovaly strojový kód s volání funkcí pro alokaci a dealokaci paměti.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Benchmarky</div>
<div class="paragraph">
<p><em>As-if</em> pravidlo je důležité pro psaní <strong><em>benchmarků</em></strong>, tj. programů, kde se snažíme <strong>změřit dobu běhu nějaké operace</strong>. V takovém případě je nutné zajistit, aby tato operace měla pozorovatelný efekt, jinak ji překladač může v rámci optimalizací eliminovat a benchmark poté bude dávat irelevantní výsledky. Například ve frameworku <em>Google/Benchmark</em> je tento problém adresován funkcí <code>benchmark::DoNotOptimize</code>.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Souhrn</div>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; funguje na základě <strong>překladu zdrojového kódu na strojový kód procesoru</strong>.</p>
</li>
<li>
<p>Implementace C&#43;&#43; zajišťuje, aby vygenerovaný strojový kód na daném počítači měl <strong>stejné pozorovatelné chování</strong>, které mu podle zdrojového kódu předepisuje standard C&#43;&#43;.</p>
</li>
<li>
<p>Překladače se v rámci optimalizací snaží vygenerovat <strong>co nejefektivnější strojový kód</strong>, které toto chování zajistí.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "cs";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;všechna práva vyhrazena.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>