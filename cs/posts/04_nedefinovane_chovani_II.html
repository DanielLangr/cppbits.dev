<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="Nedefinované chování umožňuje generovat efektivní a výkonné programy, a obecně ho nelze detekovat.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../favicon/favicon.png">
<title>04: Nedefinované chování II.</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>04: Nedefinované chování II.</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">říjen 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../../en/posts/04_undefined_behavior_II.html">English version</a> <span class="image"><a class="image" href="../../en/posts/04_undefined_behavior_II.html"><img src="https://www.countryflags.io/gb/shiny/24.png" alt="English version"></a></span><br>
<a href="../index.html">Úvodní stránka</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Writing in C or C&#43;&#43; is like running a chain saw with all the safety guards removed.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bob Gray
</div>
</div>
<div class="paragraph">
<p>Nedefinované chování je velmi nebezpečné, především z důvodu, že program vygenerovaný z příslušného zdrojového kódu se často <strong>chová zdánlivě „očekávaným“ způsobem</strong>. Typickým argumentem v diskuzích je, že „když se program chová dle očekávání, tak jeho zdrojový kód přece musí být v pořádku“. Nic nemůže být vzdálenější skutečnosti.</p>
</div>
<div class="paragraph">
<p>Prvním problémem je, že pod očekávaným chováním si <strong>každý může představit něco jiného</strong>. Jednoduchý příklad:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  int i;
  return i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podle standardu C&#43;&#43; má proměnná <code>i</code> díky absenci inicializace <strong>neurčitou hodnotu</strong>. Její <strong>vyhodnocení</strong> v rámci <code>return i;</code> poté vede na nedefinované chování. Pokud však budeme předpokládat, že implementace C&#43;&#43; zdrojový kód přeloží a vygeneruje spustitelný program, jaké bude jeho <strong>očekávané chování</strong>? Jsou zde <strong>dvě základní možnosti</strong>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Dojde k normálnímu ukončení programu s <strong>návratovým statusem 0</strong>.</p>
</li>
<li>
<p>Dojde k normálnímu ukončení programu s <strong>návratovým statusem libovolné hodnoty, která může být nulová i nenulová</strong>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Očekávané chování zde tedy závisí na tom, které z těchto variant dá kdo přednost.</p>
</div>
<div class="paragraph">
<p>Jak se zachová <strong>implementace</strong>? Nejprve jsem přeložil kód pomocí příkazu <code>g++ -O2 main.cpp</code>, který vedl na vygenerování těchto instrukcí:</p>
</div>
<div class="listingblock">
<div class="title">g&#43;&#43;</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">xor eax, eax
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Chování programu je tedy definované jako jeho normální ukončení s návratovým statusem 0, což odpovídá <strong>první možnosti očekávaného chování</strong>. Pokud jsem však použil <strong>jinou implementaci C&#43;&#43;</strong> založenou na překladači Clang (<code>clang++ -O2 main.cpp</code>), obdržel jsem jiný strojový kód:</p>
</div>
<div class="listingblock">
<div class="title">clang&#43;&#43;</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ta definuje chování programu jako jeho normální ukončení s návratovým statusem, jehož hodnota je určená obsahem registru <code>eax</code> před voláním funkce <code>main</code>. A to odpovídá <strong>druhé možnosti očekávaného chování</strong>. Já jsem například při prvním spuštění dostal návratový status 32, při následných spuštěních pak i jiné hodnoty. Problém by mohl nastat, pokud by programátor při testovacím spuštění obdržel návratový status 0. Mohl by pak <strong>mylně očekávat</strong>, že ho program vrátí vždy.</p>
</div>
<div class="paragraph">
<p>Na tomto akademickém příkladu je vidět záludnost nedefinovaného chování. Obecně se může stát, že program, který podle zdrojového kódu vede na nedefinované chování, bude <strong>v praxi fungovat dle očekávání</strong>. Může například úspěšně projít rozsáhlým systémem testování a následně být nasazen do provozu. Zde ale, po nějaké době bezproblémového fungování, <strong>zdánlivě bez jakékoliv příčiny</strong> dojde k problému (způsobeného například tím, že, jako v našem případě, nějaká funkce vrátí najednou jinou hodnotu než bylo očekáváno).</p>
</div>
<div class="paragraph">
<p>Tyto problémy navíc mohou být <strong>velmi obtížně zjistitelné</strong>. <strong>V lepším případě</strong> program zhavaruje. Pokud se ale pak při opakovaném testování a ladění program opět začne chovat očekávaně, je nalezení chyby často skoro nemožné. <strong>V horším případě</strong> navíc program „tiše“ poběží dál, ale jeho stav nebude v pořádku. To se obecně může projevit úplně někde jinde a někdy jindy. V takovém případě je nalezení příčiny problému ještě nemožnější.</p>
</div>
<div class="paragraph">
<p>Nabízí se tedy dvě otázky?</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Proč nedefinované chování vůbec <strong>existuje</strong>?</p>
</li>
<li>
<p>A zda ho lze <strong>odhalit</strong>?</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Formulace první otázky je ve skutečnosti <strong>zavádějící</strong>. Podle definice nedefinovaného chování bychom se totiž správně měli ptát, proč standard C&#43;&#43; definuje chování program <strong>pouze pokud jsou splněna určitá pravidla</strong>. Jinak řečeno, proč nedefinuje chování programu <strong>za všech okolností</strong>.</p>
</div>
<div class="paragraph">
<p>Odpověď na tuto otázku je, že i kdyby to teoreticky bylo možné, tak by to mělo <strong>obrovský negativní dopad na výkon a efektivitu programů</strong>. Opět si uvedeme příklad. Uvažujme následující zdrojový soubor:</p>
</div>
<div class="listingblock">
<div class="title">lib.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int dereference_int(int* ptr)
{
  return *ptr;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Podle standardu lze ukazatel <code>ptr</code> dereferencovat pouze <strong>pokud ukazuje na existující objekt typu <code>int</code></strong>. Jak by to ale implementace při překladu souboru <code>soruce.cpp</code> mohla zjisit? Ukazatel reprezentuje adresu, čili jeho bitová reprezentace na 64-bitovém systému má 8 bytů. Kdybychom chtěli přidat <strong>informaci o jeho „platnosti“</strong>, museli bychom nějaké místo přidat. To samo o sobě už by vedlo na nižší paměťovou efektivitu.</p>
</div>
<div class="paragraph">
<p>Dále by narostla časová režie samotné funkce <code>dereference_int</code>. V mém případě při přeložení pomocí <code>g++ -O2 -c lib.cpp</code> vznikly tyto instrukce:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">mov eax, DWORD PTR [rdi]
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>To představuje <strong>optimální strojový kód</strong>&#8201;&#8212;&#8201;je přečtena hodnota z paměti na adrese dané argumentem funkce (obsah registru <code>rdi</code>) a následně je vrácena na místo volání funkce (přes registr <code>eax</code>). Testování platnosti ukazatele by navíc vyžadovalo dodatečné instrukce realizující podmíněný skok a například vyvolání výjimky.</p>
</div>
<div class="paragraph">
<p>Ze všeho nejhorší by ale bylo, že by musel existovat mechanizmus, který by při <strong>ukončení životnosti</strong> libovolného objektu o této skutečnosti <strong>informoval všechny na něj navázané ukazatele (a reference)</strong>. Jedině tak by se totiž ukazatel „dozvěděl“ o svém zneplatnění. Paměťová a časové režie takovéhoto mechanizmu by byla devastující.</p>
</div>
<div class="paragraph">
<p>Jinými slovy se dá říct, že koncept nedefinovaného chování <strong>umožňuje implementaci zaměřit se na co nejvyšší výkon a efektivitu</strong>. K dosažení tohoto cíle ale musí mít možnost předpokládat, že <strong>jsou splněna pravidla</strong> obsažená ve standardu C&#43;&#43;, a ostatní situace neřešit.</p>
</div>
<div class="paragraph">
<p>Nyní nám zbývá druhá otázka, a sice, zda lze nedefinované chování <strong>odhalit</strong>. Obecně to bohužel <strong>možné není</strong>. Pro příklad předpokládejme, že kromě výše ukázaného zdrojového souboru <code>lib.cpp</code> máme ještě následující druhý zdrojový soubor:</p>
</div>
<div class="listingblock">
<div class="title">prog.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int dereference_int(int*);

int main()
{
  int* ptr;
  {
    int i = 1;
    ptr = &amp;i;
  }
  return dereference_int(ptr);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokud nyní chceme z obou zdrojových souborů <code>lib.cpp</code> a <code>prog.cpp</code> vytvořit spustitelný program, musíme je přeložit. Důležité je si uvědomit, že tento překlad <strong>může probíhat naprosto odděleně</strong>, například i na různých počítačových systémech. To je v praxi naprosto běžné při využívání knihoven. V našem případě může knihovnu imitovat strojový kód v souboru <code>lib.o</code> získaný překladem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">g++ -O2 -c lib.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nyní předpokládejme, že tuto „knihovnu“ chceme použít pro tvorbu programu se zdrojovým kódem <code>prog.cpp</code>. K tomu ho musíme nejprve <strong>přeložit</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">g++ -O2 -c prog.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>čímž získáme soubor se strojovým kódem <code>prog.o</code>. Pro vytvoření <strong>výsledného spustitelného souboru</strong> musíme nakonec oba vzniklé soubory <strong>„spojit“</strong> dohromady, k čemuž slouží nástroj implementace nazvaný <em>linker</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">ld lib.o prog.o</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Poznámka:</em> Poslední dva kroky lze efektivně spojit do jednoho příkazu <code>g++ -O2 prog.cpp lib.o</code>. Na funkcionalitu překladu a spojení to nemá žádný vliv.</p>
</div>
<div class="paragraph">
<p>Otázkou nyní je, zda implementace vůbec může odhalit nedefinované chování způsobené dereferencí neplatného ukazatele (ukazatele na již neexistující objekt). Rozeberme si to v souvislosti s výše definovanými kroky:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Při překladu souboru <code>lib.cpp</code> <strong>není možné porušení pravidel C&#43;&#43; zjistit</strong>. Z důvodu efektivity totiž ukazatel informaci o své (ne)platnosti neobsahuje.</p>
</li>
<li>
<p>Na úrovni zdrojového kódu souboru <code>prog.cpp</code> <strong>žádná pravidla C&#43;&#43; porušena nejsou</strong>. Neplatný ukazatel je zde pouze předán jako argument do volání funkce, a to samo o sobě zakázáno není.</p>
</li>
<li>
<p>Při spojování <strong>porušení pravidel standardu C&#43;&#43; již ohladit nelze</strong>, protože tato pravidla se týkají jen zdrojového kódu. A ten už <em>linker</em> „nevidí“.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Toto byl jen jeden příklad dokazující, že <strong>nedefinované chování obecně odhalit nelze</strong>. Lze to udělat jen v <strong>omezeném a specifickém množství případů</strong>, k čemuž slouží nástroje jako je například <em>UndefinedBehaviorSanitizer (UBSan)</em> překladače <em>Clang</em>. Ten dokáže odhalit například dělení nulou či dereferenci nulového ukazatele. Případy nedefinovaného chování ilustrované v tomto článku se mu ale odhalit nepodařilo.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Souhrn</div>
<div class="ulist">
<ul>
<li>
<p>Zdrojový kód vedoucí na nedefinované chování je obecně <strong>chybný</strong>.</p>
</li>
<li>
<p>Velké nebezpečí spočívá v tom, že se překlad i výsledný program často chovají <strong>zdánlivě očekávaným způsobem</strong>. Pokud ale nastane problém, může být <strong>velmi obtížné nalézt jeho příčinu</strong>.</p>
</li>
<li>
<p>Koncept nedefinovaného chování <strong>umožňuje</strong> implementacím generovat efektivní a výkonný strojový kód.</p>
</li>
<li>
<p>Nedefinované chování lze odhalit jen v <strong>omezeném a specifickém množství případů</strong>. Obecně ho odhalit nelze.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "cs";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;všechna práva vyhrazena.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>