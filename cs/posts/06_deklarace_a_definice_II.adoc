= 06: Deklarace a definice II.
Daniel Langr <daniel.langr@gmail.com>
:revdate: prosinec 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: Pokud překladač vidí výraz volání funkce a její definici najednou, může generovat optimálnější strojový kód.

[.normal]
link:../../en/posts/06_declarations_and_definitions_II.html[English version] image:https://www.countryflags.io/gb/shiny/24.png[English version, link="../../en/posts/06_declarations_and_definitions_II.html"] +
link:../index.html[Úvodní stránka] image:up.png[link="../index.html"] 

''''

[quote, Bjarne Stroustrup]
____
If you think it's simple, then you have misunderstood the problem.
____

Posledně jsme skončili s programem sestaveným z těchto dvou zdrojových souborů:

.main2.cpp
[source]
----
int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}
----

.add.cpp
[source]
----
int add(int a, int b)
{
  return a + b;
}
----

Jeden z těch souborů obsahoval *deklaraci* funkce `add` a její použití (volání), zatímco ten druhý obsahoval její *definici*. Samozřejmě jsme mohli tuto definici dát přímo i do souboru s funkcí `main`, například tímto způsobem:

.main3.cpp
[source]
----
int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}

int add(int a, int b)
{
  return a + b;
}
----

Je mezi oběma těmito alternativami *nějaký rozdíl*? Zdrojový kód je v obou případech *úplně stejný*. Navíc je stejné i jejich *pozorovatelné chování*, kterým je normální ukončení programu s návratovým statusem 6. My to můžeme snadno vidět, ale my nejsme důležití. Na čem záleží je *jestli to může „vidět“ i překladač*.

U *druhé alternativy* odpověď zní *ano*. Překladač vidí veškerý zdrojový kód najednou, a proto může pozorovatelné chování celého programu odvodit a zajistit ho efektivním způsobem na úrovni strojového kódu. Pro ilustraci, za použití příkazu `g{plus}{plus} -O2 main3.cpp` jsem dostal následující strojový kód funkce `main`:

[source,x86asm]
----
mov eax, 6
ret
----

.Inlining
****
Jedna z důležitých optimalizačních technik překladače je tzv. *_inlining_* funkcí. To pracuje tak, že volání funkce je *virtuálně nahrazeno* jejím tělem. V našem případě, `int j = add(i, 2) + 3` je virtuálně nahrazeno kódem `int j = (i + 2) + 3;`. 

Mějte na paměti, že inlining nemá *nic společného* se specifikátorem `inline`, což může být pro začátečníky zavádějící. V našem kódu se žádný specifikátor `inline` nevyskytuje a přesto `g{plus}{plus}` aplikovalo inlining v rámci optimalizací `-O2`. `g{plus}{plus}` nám dovoluje explicitně zakázal inlining funkcí pomocí přepínače `-fno-inline`. S `g{plus}{plus} -O2 -fno-inline main3.cpp` můžeme obdržet program, který obsahuje strojový kód funkce `add` a její volání z funkce `main`.
****

Vraťme se nyní k *první alternativě* s dvěma soubory se zdrojovým kódem. Zde, při překladu `main2.cpp` překladač vidí deklaraci funkce `add` a její volání, ale neví, co tato funkce vykonává ve svém těle. Proto *nemá jinou možnost* než vygenerovat strojový kód s tímto voláním:

.main2.o
[source,x86asm]
----
sub  rsp, 8
mov  esi, 2
mov  edi, 1
call add(int, int)
add  rsp, 8
add  eax, 3
ret
----

Poté, při překladu `add.cpp` překladač vidí definici funkce `add`, ale vůbec netuší jak je tato funkce použita. Opět má jen *jedinou možnost* -- vygenerovat strojový kód funkce:

.add.o
[source,x86asm]
----
lea eax, [rdi+rsi]
ret
----

Nakonec, linker pouze *sloučí obě části strojového kódu dohromady* do spustitelného programového souboru.

Při porovnání obou alternativ, skončili jsme se *dvěma spustitelnými programy* které mají naprosto stejné pozorovatelné chování. Ale, toto chování je v obou případech zajištěno na úrovni strojového kódu *velmi odlišným způsobem*. A opravdu nemusíme být raketovými inženýry abychom uhodli, která z těchto alternativ bude za běhu programu efektivnější. Jen co se týče počtu vykonávaných instrukcí, skóre je 9:2.

.Link-time optimizations (LTO)
****
Inlining a další optimalizace mohou být aplikovány nejen překladačem. Teoreticky je může aplikovat i linker na úrovni strojového kódu. Ale, linker je, primárně, prostě linker. Navíc, obecně, optimalizace je mnohem snazší provádět pokud je k dispozici strojový kód.

Pro příklad, {cpp} nástroje od GCC a Clang umožňují *optimalizace v čase spojování _(link-time optimizations; LTO)_*. Nicméně, pro jejich aplikaci musí být překladačem vygenerované a linkeru předané dodatečné informace -- tzv. _intermediate representation_.
****

Otázku jestli rozdíl mezi oběma výše-představenými alternativami bude mít význam v praxi význam *nelze obecně zodpovědět*. Obvykle pokud funkce vykonává *velké množství operací* tak má její inlining zanedbatelný efekt z hlediska výkonu programu. To samé pravděpodobně bude platit i o funkci, která je při běhu programu volána *párkrát nebo dokonce jen jednou*. Obecně platí, že inlining může mít přínos především pro *„krátké“ funkce, které jsou volány často*.

.Souhrn
****
- Překladač může generovat výrazně více optimalizovaný strojový kód pokud vidí *volání funkce a její definici* najednou.
- Aplikace techniky inlining funkcí *nesouvisí* se specifikátorem `inline`.
- Inlining je specificky důležitý pro *často volané funkce, které vykonávají jen malé množství operací*.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
