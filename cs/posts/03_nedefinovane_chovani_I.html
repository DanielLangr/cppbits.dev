<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="Pokud nejsou dodržena pravidla standardu C&#43;&#43;, chování implementace není definováno.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../favicon/favicon.png">
<title>03: Nedefinované chování I.</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>03: Nedefinované chování I.</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">říjen 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../../en/posts/03_undefined_behavior_I.html">English version</a> <span class="image"><a class="image" href="../../en/posts/03_undefined_behavior_I.html"><img src="https://www.countryflags.io/gb/shiny/24.png" alt="English version"></a></span><br>
<a href="../index.html">Úvodní stránka</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Writing in C or C&#43;&#43; is like running a chain saw with all the safety guards removed.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bob Gray
</div>
</div>
<div class="paragraph">
<p>Jak již bylo řečeno, standard C&#43;&#43; definuje jak se má program chovat na abstraktním počítači na základě zdrojového kódu, ze kterého byl vygenerován. Implementace C&#43;&#43; poté zajistí, aby stejné pozorovatelné chování měl i program na konkrétním počítačovém systému.</p>
</div>
<div class="paragraph">
<p>Standard C&#43;&#43; ale nedefinuje chování programu <strong>za všech okolností</strong>. Definuje ho pouze v případě, že jsou <strong>dodržena v něm obsažená pravidla</strong>. Pokud tomu tak není, chování programu standard nedefinuje. Takový případ se označuje pojmem <strong>nedefinované chování</strong> <em>(undefined behavior</em>&#8201;&#8212;&#8201;zkráceně <em>UB)</em>.</p>
</div>
<div class="paragraph">
<p>Nedefinované chování se netýká jen <strong>doby běhu programu</strong> <em>(runtime)</em>. Pokud nejsou dodržena pravidla standardu, které se týkají <strong>překladu zdrojového kódu</strong>, standard nedefinuje chování implementace ani v <strong>době překladu</strong> <em>(compile time)</em>. Obecně se tedy dá říct, že při nedefinovaném chování, tj. nedodržení pravidel standardu C&#43;&#43;, se implementace C&#43;&#43; může <strong>chovat libovolným způsobem</strong>. A to v době překladu zdrojového kódu i v době běhu vygenerovaného programu (v případě, že byl vůbec vygenerován).</p>
</div>
<div class="paragraph">
<p>Příkladem konkrétního pravidla standardu je, že u <strong>celočíselných typů se znaménkem</strong> <em>(signed)</em> nesmí dojít k <strong>přetečení</strong> <em>(overflow)</em>. Z takového přetečení tedy vyplývá nedefinované chování:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">#include &lt;limits&gt;

int main()
{
  int i = std::numeric_limits&lt;int&gt;::max();
  i++;
  return i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tento zdrojový kód může vést na nedefinované chování <strong>již v čase překladu</strong>. V rámci optimalizací totiž problematický inkrement může vyhodnocovat překladač. Oproti tomu následující zdrojový kód:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">#include &lt;iostream&gt;
#include &lt;limits&gt;

int main()
{
  int i;
  std::cin &gt;&gt; i;
  i++;
  return i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>způsobí přetečení a tedy nedefinované chování pouze pokud je ze standardního vstupu přečtena maximální hodnota typu <code>int</code>. Porušení pravidel standardu zde tedy nemůže nastat dříve než <strong>v čase běhu programu</strong>.</p>
</div>
<div class="paragraph">
<p>Velmi často kladenou otázkou je, <strong>co se ve skutečnosti stane</strong>, pokud chování není definované. Vraťme se ke zdrojovému kódu <code>main.cpp</code>. V mém případě jeho překlad pomocí <code>g++ -O2 main.cpp</code> vygeneroval následující instrukce strojového kódu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">mov eax, -2147483648
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Je chování tohoto programu <strong>na úrovni strojového kódu</strong> nedefinované? V žádném případě. Instrukce zcela jasně <strong>jeho chování definují</strong>&#8201;&#8212;&#8201;jedná se o normální ukončení programu s návratovým statusem -2147483648. Program tedy definované chování má, ale to bylo v tomto případě <strong>definované implementací</strong>. Z perspektivy standardu C&#43;&#43; zůstává chování nadále nedefinované.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Nedefinované chování a přenositelnost</div>
<div class="paragraph">
<p>Z nedefinovaného chování na úrovni standardu C&#43;&#43; vyplývá <strong>nepřenositelnost příslušného zdrojového kódu</strong>. Chování programu sice může dodatečně definovat implementace C&#43;&#43;, ale není předepsáno standardem jaké by to chování mělo být. Různé implementace tudíž mohou vygenerovat program se <strong>zcela odlišným chováním</strong>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Podívejme se na jiný příklad:</p>
</div>
<div class="listingblock">
<div class="title">main2.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  float f = 0.0f;
  int* pi = reinterpret_cast&lt;int*&gt;(&amp;f);
  return *pi;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>reinterpret_cast</code> nám umožňuje, abychom se na <strong>bitovou reprezentaci</strong> objektu nějakého typu podívali jako by to byla bitová reprezentace objektu <strong>jiného typu</strong>. V našem případě chceme zjistit, jaká je hodnota objektu typu <code>int</code>, který má <strong>stejnou bitovou reprezentaci</strong> jako má objekt typu <code>float</code> s nulovou hodnotou.</p>
</div>
<div class="paragraph">
<p>Problémem našeho kódu však je, že standard C&#43;&#43; dovoluje použít <code>reinterpret_cast</code> jen ve <strong>velmi malém a specifickém počtu případů</strong>, mezi které ten náš <strong>nepatří</strong>. Díky tomu dochází na úrovni standardu opět na nedefinované chování. Jak se zachová implementace? Já jsem v případě překladu pomocí <code>g++ -O2 main2.cpp</code> obdržel program s těmito instrukcemi:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">xor eax, eax
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeho chování je samozřejmě opět zcela přesně definované (normální ukončení programu s návratovým statusem 0).</p>
</div>
<div class="paragraph">
<p>Otázkou zůstává, zda je zde <strong>zaručeno</strong>, že se vygenerovaný program bude chovat tímto způsobem. Standard C&#43;&#43; to samozřejmě nezaručuje. Implementace to zaručovat <strong>může, ale také nemusí</strong>, a přesnou odpověď může být velmi komplikované až takřka nemožné zjistit. Dobrou zprávou je, že se implementace většinou (ne-li vždy) chovají <strong>deterministicky</strong>. Je tedy velmi pravděpodobné, že v našem případě vygeneruje překladač <code>g++</code> spustitelný soubor s uvedeným chováním vždy při dodržení stejné konfigurace překladu.</p>
</div>
<div class="paragraph">
<p>V některých případech dokonce implementace C&#43;&#43; <strong>explicitně</strong> definuje chování programu, které by podle standardu samotného bylo nedefinované. Příkladem může být stejný problém&#8201;&#8212;&#8201;náhled na bitovou reprezentaci objektu jednoho typu přes objekt jiného typu&#8201;&#8212;&#8201;ale tentokrát řešený pomocí třídního typu <code>union</code>. Ten na rozdíl od třídních typů <code>class</code> a <code>struct</code> ukládá své členské proměnné v paměti <strong>nikoliv za sebou, ale přes sebe</strong>. Alternativní řešení problému z kódu <code>main2.cpp</code> by tedy mohlo vypadat následovně:</p>
</div>
<div class="listingblock">
<div class="title">main3.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">union U
{
  float f;
  int i;
};

int main()
{
  U u;
  u.f = 0.0f;
  return u.i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Členské proměnné <code>f</code> a <code>i</code> objektu <code>u</code> jsou zde uloženy <strong>na stejné adrese</strong>, tj. v paměti se jejich bitové reprezentace <strong>překrývají</strong>. Zápisem hodnoty do jedné proměnné a čtením druhé tedy zdánlivě vyřešíme zadanou úlohu.</p>
</div>
<div class="paragraph">
<p>Standard C&#43;&#43; ale takovéto použití třídního typu <code>union</code> <strong>neumožňuje</strong>. Podle pravidel standardu je totiž u objektu typu <code>union</code> možné <strong>číst jen tu tzv. <em>aktivní</em> členskou proměnnou</strong>, což je ta, která byla <strong>naposledy zapsána</strong>. V našem případě toto pravidlo splněno není, protože po zápisu do <code>u.f</code> dojde ke čtení neaktivní <code>u.i</code>.</p>
</div>
<div class="paragraph">
<p>Přesto překlad pomocí <code>g++ -O2 main3.cpp</code> opět vedl na program s definovaných chováním na úrovni instrukcí procesoru:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">xor eax, eax
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>V tomto případě bylo ale chování vygenerovaného programu <strong>explicitně zaručeno implementací</strong>. GCC totiž ve své dokumentaci deklaruje, že definuje chování i při <strong>čtení neaktivní členské proměnné</strong> objektu typu <code>union</code> (viz např. <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type-punning" class="bare">https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type-punning</a>). Jedná se tedy o <strong>„nadstandardní“ rozšíření jazyka C&#43;&#43;</strong>.</p>
</div>
<div class="paragraph">
<p>Jako jiným případ nedefinovaného chování, které je <strong>„tolerováno“ v praxi</strong>, může sloužit snaha o implementaci kontejneru <code>std::vector&lt;T&gt;</code> ze standardní knihovny C&#43;&#43; (tento případ je spíše pro pokročilé). Vektor představuje dynamické pole prvků typu <code>T</code>. Z důvodu efektivity má objekt vektoru <strong>alokovanou paměť pro určité množství prvků</strong>, ale počet aktuálně uložených prvků může být i menší. (Tento koncept zaručuje <strong>amortizovanou konstantní složitost</strong> často používané operace <strong>přidání prvku na konec vektoru</strong>.)</p>
</div>
<div class="paragraph">
<p>Předpokládejme, že na alokovanou paměť ukazuje členská proměnná vektoru <code>data_</code> typu <code>T*</code>. Alokace paměti pro uložení <code>n</code> prvků by pak mohla vypadat následovně:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">data_ = (T*)::operator new(n * sizeof(T));</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Alokátory a alokační funkce</div>
<div class="paragraph">
<p><code>std::vector</code> provádí ve skutečnosti alokaci <strong>pomocí alokátoru</strong>, jehož typ představuje jeho druhý šablonový argument. <strong>Výchozí hodnota</strong> typu alokátoru pro <code>std::vector&lt;T&gt;</code> je <code>std::allocator&lt;T&gt;</code>. Alokace pomocí tohoto typu alokátoru je <strong>efektivně ekvivalentní</strong> s výše zmíněnou alokací pomocí operátoru <code>new</code>.</p>
</div>
<div class="paragraph">
<p><code>::operator new</code> představuje <strong>alokační funkci C&#43;&#43;</strong> určenou pro dynamickou alokaci bloku <strong>neinicializované paměti</strong> o požadovaném počtu bytů. Pokud s touto funkcí nejste obeznámeni, můžete si místo ní pro účely tohoto článku zjednodušeně představit volání funkce <code>malloc</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>V alokovaném bloku paměti, na který ukazuje ukazatel <code>data_</code>, jsou následně <strong>na určitých místech vytvářeny prvky vektoru</strong>&#8201;&#8212;&#8201;objekty typu <code>T</code> (jak je to zajištěno si povíme někdy v budoucnu). Pro <strong>přístup k prvkům vektoru</strong> je dále definován členský <strong>operátor indexace</strong>, typicky následujícím způsobem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">T&amp; operator[](size_type n) { return data_ + n; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A zde nastává problém. Tento operátor totiž obsahuje <strong>aritmetickou operaci nad ukazatelem</strong> <em>(pointer arithmetic)</em> typu <code>T*</code>. Takovou operaci standard C&#43;&#43; povoluje nad <strong>polem objektů typu <code>T</code></strong>. My ale máme <strong>blok neinicializované paměti</strong>, ve které byly následně <strong>na jistých místech vytvořeny objekty typu <code>T</code></strong>. A to podle standardu <strong>není pole typu <code>T</code></strong>. Aritmetika s ukazatelem v takovém případě vede na nedefinované chování.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Je <code>std::vector</code> implementovatelný?</div>
<div class="paragraph">
<p>Dostali jsme se do <strong>paradoxní situace</strong>&#8201;&#8212;&#8201;standard předepisuje, jak se má vektor chovat, ale zároveň snaha o jeho implementaci <strong>prakticky nevyhnutelně vede na nedefinované chování</strong>. Na toto téma se vedly a vedou rozsáhlé diskuze. Dobrou zprávou je, že implementace C&#43;&#43; o tomto problému dobře ví a <strong>správné chování vektoru zajišťují i nad rámec standardu</strong>.</p>
</div>
<div class="paragraph">
<p>Uvedenou problematiku adresuje <em>proposal</em> dokumentu P0593R6, dostupný například zde: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0593r6.html" class="bare">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0593r6.html</a>. Tento <em>proposal</em> by měl být součástí standardu <strong>C&#43;&#43;20</strong> (v době psaní tohoto článku dosud oficiálně nevydaného).</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Souhrn</div>
<div class="ulist">
<ul>
<li>
<p>K nedefinovanému chování vede <strong>nedodržení pravidel standardu C&#43;&#43;</strong>.</p>
</li>
<li>
<p>Při nedefinovaném chování standard <strong>nepředepisuje</strong>, jak se má implementace C&#43;&#43; pro daný zdrojový kód chovat. Ta se poté může chovat <strong>libovolným způsobem</strong>, a to v <strong>čase překladu</strong> i v <strong>čase běhu programu</strong>.</p>
</li>
<li>
<p>Implementace se v takových případech obecně <strong>chovají deterministicky</strong>. Obvykle vygenerují program, jehož chování je <strong>definované jeho strojovým kódem</strong>.</p>
</li>
<li>
<p>Nedefinované chování obecně vede na <strong>nepřenositelný zdrojový kód</strong>&#8201;&#8212;&#8201;ve smyslu, že se pro něj <strong>různé implementace</strong> mohou chovat <strong>odlišným způsobem</strong>.</p>
</li>
<li>
<p>V některých případech implementace C&#43;&#43; <strong>explicitně definuje chování</strong>, i když podle standardu definované není.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "cs";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;všechna práva vyhrazena.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>