= 04: Nedefinované chování II.
Daniel Langr <daniel.langr@gmail.com>
:revdate: říjen 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: Nedefinované chování umožňuje generovat efektivní a výkonné programy, a obecně ho nelze detekovat.

[.normal]
link:../../en/posts/04_undefined_behavior_II.html[English version] image:https://www.countryflags.io/gb/shiny/24.png[English version, link="../../en/posts/04_undefined_behavior_II.html"] +
link:../index.html[Úvodní stránka] image:up.png[link="../index.html"] 

''''

[quote, Bob Gray]
____
Writing in C or {cpp} is like running a chain saw with all the safety guards removed.
____

Nedefinované chování je velmi nebezpečné, především z důvodu, že program vygenerovaný z příslušného zdrojového kódu se často *chová zdánlivě „očekávaným“ způsobem*. Typickým argumentem v diskuzích je, že „když se program chová dle očekávání, tak jeho zdrojový kód přece musí být v pořádku“. Nic nemůže být vzdálenější skutečnosti.

Prvním problémem je, že pod očekávaným chováním si *každý může představit něco jiného*. Jednoduchý příklad:

.main.cpp
[source]
----
int main()
{ 
  int i;
  return i;
}
----

Podle standardu {cpp} má proměnná `i` díky absenci inicializace *neurčitou hodnotu*. Její *vyhodnocení* v rámci `return i;` poté vede na nedefinované chování. Pokud však budeme předpokládat, že implementace {cpp} zdrojový kód přeloží a vygeneruje spustitelný program, jaké bude jeho *očekávané chování*? Jsou zde *dvě základní možnosti*:

. Dojde k normálnímu ukončení programu s *návratovým statusem 0*.
. Dojde k normálnímu ukončení programu s *návratovým statusem libovolné hodnoty, která může být nulová i nenulová*.

Očekávané chování zde tedy závisí na tom, které z těchto variant dá kdo přednost. 

Jak se zachová *implementace*? Nejprve jsem přeložil kód pomocí příkazu `g++ -O2 main.cpp`, který vedl na vygenerování těchto instrukcí:

.g{plus}{plus}
[source,x86asm]
----
xor eax, eax
ret
----

Chování programu je tedy definované jako jeho normální ukončení s návratovým statusem 0, což odpovídá *první možnosti očekávaného chování*. Pokud jsem však použil *jinou implementaci {cpp}* založenou na překladači Clang (`clang++ -O2 main.cpp`), obdržel jsem jiný strojový kód:

.clang{plus}{plus}
[source,x86asm]
----
ret
----

Ta definuje chování programu jako jeho normální ukončení s návratovým statusem, jehož hodnota je určená obsahem registru `eax` před voláním funkce `main`. A to odpovídá *druhé možnosti očekávaného chování*. Já jsem například při prvním spuštění dostal návratový status 32, při následných spuštěních pak i jiné hodnoty. Problém by mohl nastat, pokud by programátor při testovacím spuštění obdržel návratový status 0. Mohl by pak *mylně očekávat*, že ho program vrátí vždy. 

Na tomto akademickém příkladu je vidět záludnost nedefinovaného chování. Obecně se může stát, že program, který podle zdrojového kódu vede na nedefinované chování, bude *v praxi fungovat dle očekávání*. Může například úspěšně projít rozsáhlým systémem testování a následně být nasazen do provozu. Zde ale, po nějaké době bezproblémového fungování, *zdánlivě bez jakékoliv příčiny* dojde k problému (způsobeného například tím, že, jako v našem případě, nějaká funkce vrátí najednou jinou hodnotu než bylo očekáváno). 

Tyto problémy navíc mohou být *velmi obtížně zjistitelné*. *V lepším případě* program zhavaruje. Pokud se ale pak při opakovaném testování a ladění program opět začne chovat očekávaně, je nalezení chyby často skoro nemožné. *V horším případě* navíc program „tiše“ poběží dál, ale jeho stav nebude v pořádku. To se obecně může projevit úplně někde jinde a někdy jindy. V takovém případě je nalezení příčiny problému ještě nemožnější.

Nabízí se tedy dvě otázky?

. Proč nedefinované chování vůbec *existuje*?
. A zda ho lze *odhalit*?

Formulace první otázky je ve skutečnosti *zavádějící*. Podle definice nedefinovaného chování bychom se totiž správně měli ptát, proč standard {cpp} definuje chování program *pouze pokud jsou splněna určitá pravidla*. Jinak řečeno, proč nedefinuje chování programu *za všech okolností*.

Odpověď na tuto otázku je, že i kdyby to teoreticky bylo možné, tak by to mělo *obrovský negativní dopad na výkon a efektivitu programů*. Opět si uvedeme příklad. Uvažujme následující zdrojový soubor:

.lib.cpp
[source]
----
int dereference_int(int* ptr)
{
  return *ptr;
}
----

Podle standardu lze ukazatel `ptr` dereferencovat pouze *pokud ukazuje na existující objekt typu `int`*. Jak by to ale implementace při překladu souboru `soruce.cpp` mohla zjisit? Ukazatel reprezentuje adresu, čili jeho bitová reprezentace na 64-bitovém systému má 8 bytů. Kdybychom chtěli přidat *informaci o jeho „platnosti“*, museli bychom nějaké místo přidat. To samo o sobě už by vedlo na nižší paměťovou efektivitu.

Dále by narostla časová režie samotné funkce `dereference_int`. V mém případě při přeložení pomocí `g++ -O2 -c lib.cpp` vznikly tyto instrukce:

[source,x86asm]
----
mov eax, DWORD PTR [rdi]
ret
----

To představuje *optimální strojový kód* -- je přečtena hodnota z paměti na adrese dané argumentem funkce (obsah registru `rdi`) a následně je vrácena na místo volání funkce (přes registr `eax`). Testování platnosti ukazatele by navíc vyžadovalo dodatečné instrukce realizující podmíněný skok a například vyvolání výjimky.

Ze všeho nejhorší by ale bylo, že by musel existovat mechanizmus, který by při *ukončení životnosti* libovolného objektu o této skutečnosti *informoval všechny na něj navázané ukazatele (a reference)*. Jedině tak by se totiž ukazatel „dozvěděl“ o svém zneplatnění. Paměťová a časové režie takovéhoto mechanizmu by byla devastující.

Jinými slovy se dá říct, že koncept nedefinovaného chování *umožňuje implementaci zaměřit se na co nejvyšší výkon a efektivitu*. K dosažení tohoto cíle ale musí mít možnost předpokládat, že *jsou splněna pravidla* obsažená ve standardu {cpp}, a ostatní situace neřešit.

Nyní nám zbývá druhá otázka, a sice, zda lze nedefinované chování *odhalit*. Obecně to bohužel *možné není*. Pro příklad předpokládejme, že kromě výše ukázaného zdrojového souboru `lib.cpp` máme ještě následující druhý zdrojový soubor:

.prog.cpp
[source]
----
int dereference_int(int*);

int main()
{
  int* ptr;
  {
    int i = 1;
    ptr = &i;
  }
  return dereference_int(ptr);
}
----

Pokud nyní chceme z obou zdrojových souborů `lib.cpp` a `prog.cpp` vytvořit spustitelný program, musíme je přeložit. Důležité je si uvědomit, že tento překlad *může probíhat naprosto odděleně*, například i na různých počítačových systémech. To je v praxi naprosto běžné při využívání knihoven. V našem případě může knihovnu imitovat strojový kód v souboru `lib.o` získaný překladem:

[source,text]
----
g++ -O2 -c lib.cpp
----

Nyní předpokládejme, že tuto „knihovnu“ chceme použít pro tvorbu programu se zdrojovým kódem `prog.cpp`. K tomu ho musíme nejprve *přeložit*:

[source,text]
----
g++ -O2 -c prog.cpp
----

čímž získáme soubor se strojovým kódem `prog.o`. Pro vytvoření *výsledného spustitelného souboru* musíme nakonec oba vzniklé soubory *„spojit“* dohromady, k čemuž slouží nástroj implementace nazvaný _linker_:

[source,text]
----
ld lib.o prog.o
----

_Poznámka:_ Poslední dva kroky lze efektivně spojit do jednoho příkazu `g++ -O2 prog.cpp lib.o`. Na funkcionalitu překladu a spojení to nemá žádný vliv.

Otázkou nyní je, zda implementace vůbec může odhalit nedefinované chování způsobené dereferencí neplatného ukazatele (ukazatele na již neexistující objekt). Rozeberme si to v souvislosti s výše definovanými kroky:

- Při překladu souboru `lib.cpp` *není možné porušení pravidel {cpp} zjistit*. Z důvodu efektivity totiž ukazatel informaci o své (ne)platnosti neobsahuje.

- Na úrovni zdrojového kódu souboru `prog.cpp` *žádná pravidla {cpp} porušena nejsou*. Neplatný ukazatel je zde pouze předán jako argument do volání funkce, a to samo o sobě zakázáno není.

- Při spojování *porušení pravidel standardu {cpp} již ohladit nelze*, protože tato pravidla se týkají jen zdrojového kódu. A ten už _linker_ „nevidí“.
 
//K odhalení nedefinovaného chování by v našem případě překladač musel mít k dispozici oba zdrojové soubory najednou. To v praxi obecně není možné zajistit. Jak jsme již zmínili, překlad souboru `prog.cpp` může probíhat na místě, kde se soubor `lib.cpp` vůbec nevyskytuje. K takovým situacím dochází dennodenně při použití knihoven, které jsou do systémů distribuovány v binární podobě. K nim sice jsou k dispozici příslušné hlavičkové soubory knihovny, ale ty většinou obsahují pouze deklarace knihovních funkcí.

//Teoreticky by se dalo namítnout, že by nedefinované chování mohl odhalit právě linker. To ale také nelze. Chování programu na úrovni vygenerovaného strojového kódu v souborech `lib.o` a `prog.o` může být (a pravděpodobně bude) již jasně definované. Nedefinované chování existuje pouze na úrovni standardu {cpp} a linker nemůže zjistit, že jestli byla nebo nebyla porušena jeho pravidla.

Toto byl jen jeden příklad dokazující, že *nedefinované chování obecně odhalit nelze*. Lze to udělat jen v *omezeném a specifickém množství případů*, k čemuž slouží nástroje jako je například _UndefinedBehaviorSanitizer (UBSan)_ překladače _Clang_. Ten dokáže odhalit například dělení nulou či dereferenci nulového ukazatele. Případy nedefinovaného chování ilustrované v tomto článku se mu ale odhalit nepodařilo.

.Souhrn
****
- Zdrojový kód vedoucí na nedefinované chování je obecně *chybný*.
- Velké nebezpečí spočívá v tom, že se překlad i výsledný program často chovají *zdánlivě očekávaným způsobem*. Pokud ale nastane problém, může být *velmi obtížné nalézt jeho příčinu*.
- Koncept nedefinovaného chování *umožňuje* implementacím generovat efektivní a výkonný strojový kód.
- Nedefinované chování lze odhalit jen v *omezeném a specifickém množství případů*. Obecně ho odhalit nelze.

****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
