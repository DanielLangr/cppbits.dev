= 05: Deklarace a definice I.
Daniel Langr <daniel.langr@gmail.com>
:revdate: prosinec 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: Deklarace nějaké entity říká překladači že existuje a jakým způsobem může být využita. Definice funkce říká překladači aby vygeneroval její strojový kód.

[.normal]
link:../../en/posts/05_declarations_and_definitions_I.html[English version] image:https://www.countryflags.io/gb/shiny/24.png[English version, link="../../en/posts/05_declarations_and_definitions_I.html"] +
link:../index.html[Úvodní stránka] image:up.png[link="../index.html"] 

''''

[quote, Bjarne Stroustrup]
____
If you think it's simple, then you have misunderstood the problem.
____

Představme si, že -- *někde v prázdnotě* -- existuje následující funkce:

[source]
----
int add(int a, int b)
{
  return a + b;
}
----

Pokusme se nyní napsat zdrojový kód programu, který *tuto funkci použije*. První varianta by mohla vypada takto:

.main.cpp
[source]
----
int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}
----

Pokud se nyní pokusíme z tohoto zdrojového kódu *vygenerovat strojový kód* (například příkazem `g{plus}{plus} -O2 -c main.cpp`), tak to selže. Proč?

Ve zdrojovém kódu, funkce `add` je *volána* z funkce `main`. Překladač proto potřebuje vygenerovat odpovídající volání funkce `add` na úrovni strojového kódu. Na architektuře x86_64, takovéto volání je reprezentováno instrukcí `call`. Ale tato instrukce, sama o sobě, *není dostačující*.

Překladač totiž také potřebuje vygenerovat instrukce pro *předání argumentů a návratové hodnoty do/z funkce*. V našem případě, překladač „vidí“ argumenty (`i` a `2`, oba typu `int`) a také vidí co se děje s návratovou hodnotou (aplikace binárního operátoru `+`). Nicméně, toto *nestačí* pro generování odpovídajících „předávajících“ instrukcí. Například -- jsou argumenty předávané hodnotou nebo referencí? Nebo, je zde vyžadována nějaká implicitní konverze? Na úrovni strojového kódu to představuje rozdíl.

Co zde chybí pro úspěšné generování předávajících instrukcí je, že překladač potřebuje vidět i *typy funkčních parametrů a typ návratové hodnoty*. Poskytnutí těchto informací je úkolem *deklarace funkce*. V našem případě, nejjednodušší forma deklarace funkce `add` je:

[source]
----
int add(int, int);
----

Jak zajistit aby překladač *viděl tuto deklaraci* když překládá funkci `main`? Nejzákladnější řešení je jednoduše přidání deklarace do stejného zdrojového souboru:

.main2.cpp
[source]
----
int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}
----

Nyní, překlad pomocí `g{plus}{plus} -O2 -c main2.cpp` uspělo a -- v mém případě -- jsem obdržel následující instrukce vygenerované pro funkci `main`:

[source,x86asm]
----
sub  rsp, 8
mov  esi, 2
mov  edi, 1
call add(int, int)
add  rsp, 8
add  eax, 3
ret
----

.Aplikační binární rozhraní (ABI)
****
Na každém počítačovém systému musí existovat *dohoda* o tom, jak jsou předávány argumenty a návratové hodnoty do/z funkcí *na úrovni strojového kódu*. Tato dohoda je součástí něčeho, čemu se říká *aplikační binární rozhraní _(application binary interface; ABI)_*. Bez ABI, části strojového kódu vygenerované například rozdílnými překladači by nebyly schopny spolupracovat.

Na mém systému, ABI předepisuje, že hodnoty argumentů jsou -- do funkce, která má dva parametry typu `int` -- předávány přes registry procesoru `edi` a `esi`, v uvedeném pořadí. Protože u našeho volání funkce `add` mají tyto argumenty hodnoty 1 a 2, jsou tyto hodnoty přiřazeny těmto registrům. ABI dále předepisuje, že návratová hodnota typu `int` je předána z funkce přes registr `eax`. Povšimněme si, že toto platí pro obě funkce `add` a `main`. Podle zdrojového kódu, hodnota navrácená z funkce `add` je inkrementována o 3 a vrácena z funkce `main`. Na úrovni strojového kódu tento efekt zajistí inkrement registru `eax` o 3.

Nakonec, proč jsou zde ony dvě instrukce, které manipulují s registrem ukazatele zásobníku _(stack pointer_) `rsp`? Důvod rovněž souvisí s použitým ABI. To totiž předepisuje, že na začátku spuštění funkce musí být jeho část zásobníku -- tzv. _stack frame_ -- na kterou ukazuje `rsp`, zarovnána na 16 bytovou adresu.

Na začátku funkce `main` je proto adresa v `rsp` zarovnána na 16 bytové paměťové hranici. Nicméně, následná instrukce `call` uloží na zásobník aktuální hodnotu instrukčního ukazatele _(instruction pointer)_ `rip`. To je nezbytné aby instrukce `ret` ve funkci `add` věděla, kam se má běh programu vrátit zpět. 

Toto „zapamatování“ hodnoty `rip` na zásobníku zahrnuje dekrement `rsp` o hodnotu 8. Pro zajištění 16 bytového zarovnání pro _stack frame_ na začátku funkce `add`, `rsp` proto musí být dekrementován o dalších 8 bytů, což právě zjišťuje instrukce `sub rsp, 8`. Po návratu z funkce `add`, tento efekt je invertován instrukcí `add rsp, 8`.
****

Nyní jsme tedy schopni přeložit zdrojový kód souboru `main2.cpp` na strojový kód. Nicméně, tento strojový kód *zatím ještě není ve formě spustitelného programu*. Díky přepínači `-c` použitého pro překladač `g{plus}{plus} má zatím formu tzv. *objektového souboru _(object file)_*, který má implicitně název `main2.o`.

Pro sestavení spustitelného programu, všechny výskyty instrukce `call` musejí být *spojeny* _(link)_ se strojovým kódem volaných funkcí. Toto je úkolem nástroje implementace {cpp} nazvaného *_linker_*. V mém případě je linker program nazvaný `ld`, který interně využívá `g{plus}{plus} v případě, že na vstupu dostane objektový soubor.

S mojí implementací založené na `g{plus}{plus} máme nyní dvě možnosti jak sestavit spustitelný program pro `main2.cpp`. Ta první je, že *odděleně přeložíme* tento zdrojový soubor pomocí

[source,plaintext]
----
g++ -O2 -c main2.cpp
----

a výsledný `main2.o` *spojíme* do spustitelného programu příkazem

[source,plaintext]
----
g++ main2.o
----

Druhá možnost je, že *oba kroky sloučíme dohromady do jednoho příkazu:*

[source,plaintext]
----
g++ -O2 main2.cpp
----

který interně provede totéž (pouze bez explicitního uložení souboru `main2.o`).

V mém případě obě tyto možnosti vedly na následující *chybu*, kterou reportoval linker `ld`:

[source,plaintext]
----
undefined reference to `add(int, int)'
----

Příčina této chyby je zřejmá -- linker vidí instrukci `call` pro volání funkce `add`, ale nevidí žádný strojový kód této funkce, s kterým by ono *volání mohl spojit*.

Jak tedy poskytnout tento zdrojový kód? Překladač ho samozřejmě nemůže vygenerovat jen na základě deklarace funkce `add`. Místo toho potřebuje vidět *tělo funkce*, které je poskytnuto *definicí funkce*. V našem případě tato definice vypadá následovně:

[source]
----
int add(int a, int b)
{
  return a + b;
}
----

Obecně platí, že definice funkce *instruuje překladač aby vygeneroval její strojový kód*. Dejme pro začátek tuto definici funkce `add` do samostatného zdrojového souboru:

.add.cpp
[source]
----
int add(int a, int b)
{
  return a + b;
}
----

Nyní můžeme vygenerovat strojový kód funkce `add` ve formě objektového souboru `add.o` příkazem `g{plus}{plus} -O2 -c add.cpp`. Generované instrukce pro funkci byly v mém případě tyto:

[source,x86asm]
----
lea eax, [rdi+rsi]
ret
----

Instrukce `lea` sečte hodnoty argumentů funkce -- předané pomocí registrů `edi` a `esi` (na hodnotě vyšších 32 bitů registrů `rdi` a `rsi` nezáleží) -- a výsledek uloží do registru `eax`. Tento registr je poté použit pro předání výsledku na místo volání funkce.

Nyní konečně máme vše, co je potřeba pro sestavení *spustitelného programového souboru*. Uvnitř `main2.o` je volání funkce `add`. Uvnitř `add.o` je její strojový kód. Příkaz `g{plus}{plus} main2.o add.o` předá oba soubory linkeru a ten vygeneruje spustitelný soubor s výchozím názvem `a.out`.

Mimochodem, `g{plus}{plus}` nám umožňuje sloučit překlad obou zdrojových souborů a spojení výsledných objektových souborů do jednoho příkazu: `g{plus}{plus} -O2 main2.cpp add.cpp`. V mém případě byl výsledný spustitelný soubor úplně stejný.

.Souhrn
****
- *Deklarace funkce* instruuje překladač jak má *generovat strojový kód pro volání této funkce*.
- *Definice funkce* instruuje překladač aby vygeneroval její *strojový kód* (strojový kód pro její tělo).
- Pro sestavení spustitelného programu musí být instrukce volání funkce *spojeny* se strojovým kódem těchto funkcí, což je úkolem nástroje zvaného *linker*.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
