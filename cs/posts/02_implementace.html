<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="Úkolem implementace C&#43;&#43; je na konkrétním počítačovém systému zajistit pro program pozorovatelné chování, které mu podle zdrojového kódu předepisuje Standard C&#43;&#43;.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../favicon/favicon.png">
<title>02: Implementace C&#43;&#43;</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>02: Implementace C&#43;&#43;</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">říjen 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../../en/posts/02_implementation.html">English version</a> <span class="image"><a class="image" href="../../en/posts/02_implementation.html"><img src="https://www.countryflags.io/gb/shiny/24.png" alt="English version"></a></span><br>
<a href="../index.html">Úvodní stránka</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>There are only two things wrong with C&#43;&#43;: The initial concept and the implementation.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bertrand Meyer
</div>
</div>
<div class="paragraph">
<p>Jak již bylo řečeno, <strong>implementace C&#43;&#43;</strong> zajišťuje aby program spuštěný na konkrétním počítačovém systému měl takové pozorovatelné chování, jaké mu předepisuje standard C&#43;&#43; dle jeho zdrojového kódu. Implementace C&#43;&#43; obsahuje především <strong>překladač C&#43;&#43;</strong>. Pokud nebude uvedeno jinak, budeme pro jednoduchost pod tímto pojmem rozumět celou kolekci nástrojů, která je potřebná pro <strong>vygenerování spustitelného programu či knihovního souboru ze zdrojového kódu</strong>. Mimo vlastního „generátoru“ strojového kódu sem tedy zahrneme i nástroje jako jsou například <em>preprocesor</em> či <em>linker</em>.</p>
</div>
<div class="paragraph">
<p>Překladač pro implementaci C&#43;&#43; na konkrétním počítači ale sám o sobě nestačí. Standard C&#43;&#43; obsahuje <strong>dvě hlavní části</strong>. Ta první popisuje <strong>vlastní programovací jazyk</strong>, tedy například základní datové typy a operace nad nimi, funkce, třídy, šablony, apod. Druhá a mnohem obsáhlejší část (rozsahem více jak dvojnásobně v současném draftu standardu) se zabývá <strong>standardní knihovnou C&#43;&#43;</strong> <em>(C&#43;&#43; standard library)</em>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Standardní knihovna C&#43;&#43; vs STL</div>
<div class="paragraph">
<p>C&#43;&#43; standardní knihovna je někdy označována pojmem <strong><em>STL</em></strong>, což je zkratka <strong><em>standard template library</em></strong>. Někdo zase tento pojem používá pouze pro část standardní knihovny C&#43;&#43;, která se zabývá algoritmy, kontejnery a iterátory. Teoreticky je použití pojmu STL <strong>nesprávné</strong>&#8201;&#8212;&#8201;ve standardu C&#43;&#43; se vůbec neobjevuje. Přesto se v praxi <strong>zažilo a běžně na něj můžeme narazit</strong>. Microsoft například repozitář svoji implementace standardní knihovny C&#43;&#43; na GitHubu pojmenovává <em>microsoft/STL</em>, Intel svoji paralelní verzi standardní knihovny C&#43;&#43; zase nazývá <em>Parallel STL</em>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Zjednodušeně se dá říct, že první část standardu obsahuje vše, co je potřeba k napsání zdrojového kódu, který <strong>nevyužívá</strong> žádný <strong>hlavičkový soubor standardní knihovny C&#43;&#43;</strong>. (Existují výjimky&#8201;&#8212;&#8201;například se v této části popisuje alokační funkce <code>::operator new</code>, která je poskytovaná hlavičkovým souborem <code>&lt;new&gt;</code>.) Příklad takového kódu je následující:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  return 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>K vygenerování binárního spustitelného programu z tohoto zdrojového kódu stačí překladač C&#43;&#43; sám o sobě. To ale už nebude platit o následujícím zdrojovém kódu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">#include &lt;iostream&gt;

int main()
{
  std::cout &lt;&lt; 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pro vygenerování spustitelného programu a případně i pro jeho spuštění (v případě dynamického linkování) je zde navíc potřeba ještě <strong>implementace standardní knihovny C&#43;&#43;</strong>. V praxi <strong>nejpoužívanější implementace</strong> jsou&#8201;&#8212;&#8201;alespoň pro architekturu x86_64&#8201;&#8212;&#8201;<em>libstdc&#43;&#43;</em> od <em>GNU</em>, <em>libc&#43;&#43;</em> od <em>LLVM</em>, a již zmíněná <em>Microsoft STL</em>.</p>
</div>
<div class="paragraph">
<p>Některé překladače mohou spolupracovat s různými implementacemi standardní knihovny&#8201;&#8212;&#8201;například překladač <em>Clang</em> umí používat  <em>libstdc&#43;&#43;</em> i s <em>libc&#43;&#43;</em>. To, jaká knihovna bude použitá implicitně je dáno instalací a systémem. Na Linuxu <em>Clang</em> většinou implicitně použije <em>libstdc&#43;&#43;</em>, zatímco na Mac OS X to bude <em>libc&#43;&#43;</em>. Většina překladačů je ale poměrně <strong>těsně svázána</strong> s konkrétní implementaci standardní knihovny. Pro příklad, překladače od GNU (GCC) a Intelu využívají <em>libstdc&#43;&#43;</em>, překladač Microsfotu samozřejmě <em>Microsoft STL</em>.</p>
</div>
<div class="paragraph">
<p>Velkou část standardní knihovny C&#43;&#43; představují <strong>šablony</strong>. Jejich zdrojový kód musí být pro překladač „viditelný“ při překladu a proto ho lze u implementací najít ve formě <strong>hlavičkových souborů</strong>. <strong>Kompletní zdrojový kód</strong> zmíněných implementací je navíc dostupný i formou <strong>repozitářů na GitHubu</strong>, konkrétně:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>libstdc&#43;&#43;</em>: repozitář <em>gcc-mirror/gcc</em>&#8201;&#8212;&#8201;podadresář <a href="https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3"><em>libstdc&#43;&#43;-v3</em></a>,</p>
</li>
<li>
<p><em>libc&#43;&#43;</em>: repozitář <em>llvm/llvm-project</em>&#8201;&#8212;&#8201;podadresář <a href="https://github.com/llvm/llvm-project/tree/master/libcxx"><em>libcxx</em></a>,</p>
</li>
<li>
<p><em>Microsoft STL</em>: repozitář <a href="https://github.com/microsoft/STL"><em>microsoft/STL</em></a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Zdrojový kód může být vynikajícím <strong>materiálem pro učení C&#43;&#43;</strong>. Výše zmíněné implementace jsou vyvíjené se zaměřením na vysoký výkon a zároveň jsou v praxi dennodenně testované a ověřované vysokým množstvím programátorů a jejich programů. Na druhou stranu je tento kód velmi rozsáhlý a může být obtížné se v něm na první pohled zorientovat.</p>
</div>
<div class="paragraph">
<p>Studium zdrojového kódu může být také užitečné, pokud chceme pochopit, proč se implementace <strong>chová nějakým konkrétním způsobem</strong>. Pro příklad&#8201;&#8212;&#8201;všechny tři zmíněné implementace standardní knihovny C&#43;&#43; aplikují pro třídu <code>std::string</code> optimalizační techniku <strong><em>small (short) string optimization</em> (SSO)</strong>. Ta zajišťuje, že pro řetězce <strong>do určité délky</strong> není potřeba dynamická alokace paměti. Místo toho je řetězec znaků uložen <strong>v rámci bitové reprezentace objektu třídy</strong>.</p>
</div>
<div class="paragraph">
<p>Limit pro délku „krátkého“ řetězce závisí na tom, <strong>jakým způsobem</strong> je SSO implementováno. Tento limit můžeme zjistit vypsáním <strong>kapacity</strong> prázdného objektu třídy. Zároveň se podívejme i na <strong>velikost jeho bitové reprezentace</strong> zjistitelné pomocí operátoru <code>sizeof</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  std::string s;
  std::cout &lt;&lt; s.capacity() &lt;&lt; std::endl;
  std::cout &lt;&lt; sizeof s &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Já jsem na architektuře X86_64 obdržel u <em>libstdc&#43;&#43;</em> a <em>Microsoft STL</em> shodně <strong>kapacitu 15 a velikost 32</strong>, kdežto u <em>libc&#43;&#43;</em> <strong>kapacitu 22 a velikost 24</strong>. Zdánlivě je tedy <em>libc&#43;&#43;</em> výrazně efektivnější&#8201;&#8212;&#8201;do 24 bytů je schopna bez dynamické alokace uložit řetězec až o 22 znacích, kdežto ostatní dvě implementace do 32 bytů uloží maximálně 15 jen znaků.</p>
</div>
<div class="paragraph">
<p>Pro pochopení rozdílu mezi implementovanými variantami SSO je nutné podívat se do zdrojového kódu. Detailní analýza je mimo rozsah tohoto tématu (snad se k ní dostaneme v budoucnu v samostatném článku), ale ve stručnosti se dá říct, že <em>libc&#43;&#43;</em> <strong>preferuje vysokou paměťovou efektivitu na úkor té časové</strong>. Musí totiž při každém přístupu k uloženému řetězci znaků nejprve zjistit, zda je krátký (do 22 znaků) či dlouhý, a podle toho <strong>odvodit ukazatel na uložené znaky</strong>. To představuje určitou <strong>časovou režii</strong>. Oproti tomu, u <em>libstdc&#43;&#43;</em> a <em>Microsoft STL</em> má objekt třídy <code>std::string</code> ukazatel na znaky řetězce přímo uložený ve formě <strong>samostatné členské proměnné</strong>. To sice snižuje paměťovou efektivitu, ale zase zvyšuje tu časovou.</p>
</div>
<div class="paragraph">
<p>Jiným příkladem pro studium zdrojového kódu implementací standardní knihovny C&#43;&#43; může být následující problém (tento příklad je spíše <strong>pro pokročilé</strong>&#8201;&#8212;&#8201;pokud mu neporozumíte, nedělejte si s tím hlavu a prostě ho přeskočte):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">#include &lt;map&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

int main()
{
  std::vector&lt; std::map&lt;int, std::thread&gt; &gt; v;
  v.reserve(1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>V mém případě tento kód bez problému přeložily implementace používající <em>libstdc&#43;&#43;</em> i <em>libc&#43;&#43;</em>. Překlad s <em>Microsoft STL</em> ale <strong>skončil s chybou</strong>. Proč tomu tak je? Ze zdrojového kódu lze zjistit, že u <em>libstdc&#43;&#43;</em> i <em>libc&#43;&#43;</em> <strong>přesouvací konstruktor</strong> <em>(move constructor)</em> typu <code>std::map&lt;int, std::thread&gt;</code> <strong>nemůže vyhodit výjimku</strong>&#8201;&#8212;&#8201;„je“ tzv. <em>noexcept</em> (správně bychom měli říkat, že tento konstruktor má „nevyhazující specifikaci výjimky“&#8201;&#8212;&#8201;<em>non-throwing exception specification</em>). V implementaci <em>Microsoft STL</em> to ale <strong>neplatí</strong>.</p>
</div>
<div class="paragraph">
<p>Přesouvací konstruktory vyhazující výjimky jsou obecně <strong>problematické</strong>. V případě „realokační“ členské funkce <code>reserve</code> u vektoru může takové vyhození výjimky způsobit, že obsah vektoru bude po volání funkce <strong>jiný</strong> než jaký byl před tímto voláním (nebude splněna tzv. <em>strong exception guarantee</em>). Standard C&#43;&#43; proto předepisuje, že členská funkce <code>reserve</code> má v takovém případě <strong>dát přednost kopírovacímu konstruktoru</strong>.</p>
</div>
<div class="paragraph">
<p>Posledním kouskem skládačky je fakt, že objekty třídy <code>std::thread</code> jsou <strong>nekopírovatelné</strong>. To samozřejmě znamená, že nelze zkopírovat ani obsah libovolného kontejneru, který objekty této třídy obsahuje. V našem případě je to mapa <code>std::map&lt;int, std::thread&gt;</code>. U <em>Microsoft STL</em> se tedy členská funkce vektoru <code>reserve</code> snaží volat kopírovací konstruktor této mapy, což při překladu selže na nemožnosti kopírování uložených objektů typu <code>std::thread</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Která implementace je ta správná?</div>
<div class="paragraph">
<p>V popsaném případě se implementace <strong>chovají rozdílně</strong>, a to dokonce na úrovni úspěšného/neúspěšného překladu stejného zdrojového kódu. Která implementace je tedy ta správná? Odpověď je, že <strong>všechny tři</strong>. Standard C&#43;&#43; totiž <strong>nepožaduje</strong>, aby přesouvací konstruktor třídní šablony <code>std::map</code> byl <em>noexcept</em>. Na druhou stranu to ale ani <strong>nezakazuje</strong>.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Souhrn</div>
<div class="ulist">
<ul>
<li>
<p><strong>Implementace C&#43;&#43;</strong> zajišťuje aby program spuštěný na <strong>konkrétním počítačovém systému</strong> měl takové <strong>pozorovatelné chování</strong>, jaké mu předepisuje standard C&#43;&#43; <strong>dle jeho zdrojového kódu</strong>.</p>
</li>
<li>
<p>Obsahuje sadu nástrojů pro <strong>překlad</strong> zdrojového kódu na spustitelný strojový kód (preprocesor, překladač, linker, apod.) a dále <strong>implementaci standardní knihovny C&#43;&#43;</strong>.</p>
</li>
<li>
<p><strong>Nejčastěji používané implementace</strong> standardní knihovny C&#43;&#43; jsou <em>libstdc&#43;&#43;</em>, <em>libc&#43;&#43;</em>, a <em>Microsoft STL</em>. Jejich zdrojový kód je ve všech třech případech <strong>volně dostupný</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "cs";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;všechna práva vyhrazena.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>