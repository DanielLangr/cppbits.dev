<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="Deklarace nějaké entity říká překladači že existuje a jakým způsobem může být využita. Definice funkce říká překladači aby vygeneroval její strojový kód.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../../favicon/favicon.png">
<title>05: Deklarace a definice I.</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>05: Deklarace a definice I.</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">prosinec 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../../en/posts/05_declarations_and_definitions_I.html">English version</a> <span class="image"><a class="image" href="../../en/posts/05_declarations_and_definitions_I.html"><img src="https://www.countryflags.io/gb/shiny/24.png" alt="English version"></a></span><br>
<a href="../index.html">Úvodní stránka</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>If you think it&#8217;s simple, then you have misunderstood the problem.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bjarne Stroustrup
</div>
</div>
<div class="paragraph">
<p>Představme si, že&#8201;&#8212;&#8201;<strong>někde v prázdnotě</strong>&#8201;&#8212;&#8201;existuje následující funkce:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int a, int b)
{
  return a + b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokusme se nyní napsat zdrojový kód programu, který <strong>tuto funkci použije</strong>. První varianta by mohla vypadat takto:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokud se nyní pokusíme z tohoto zdrojového kódu <strong>vygenerovat strojový kód</strong> (například příkazem <code>g&#43;&#43; -O2 -c main.cpp</code>), tak to selže. Proč?</p>
</div>
<div class="paragraph">
<p>Ve zdrojovém kódu je funkce <code>add</code> <strong>volána</strong> z funkce <code>main</code>. Překladač proto potřebuje vygenerovat odpovídající volání funkce <code>add</code> na úrovni strojového kódu. Na architektuře x86_64 je takovéto volání reprezentováno instrukcí <code>call</code>. Ale tato instrukce sama o sobě <strong>není dostačující</strong>.</p>
</div>
<div class="paragraph">
<p>Překladač totiž také potřebuje vygenerovat instrukce pro <strong>předání argumentů a návratové hodnoty do/z funkce</strong>. V našem případě překladač „vidí“ argumenty (<code>i</code> a <code>2</code>, oba typu <code>int</code>) a také vidí, co se děje s návratovou hodnotou (aplikace binárního operátoru <code>+</code>). Nicméně toto <strong>nestačí</strong> pro generování odpovídajících „předávajících“ instrukcí. Například, jsou argumenty předávané hodnotou nebo referencí? Nebo, je zde vyžadována nějaká implicitní konverze? Na úrovni strojového kódu to představuje rozdíl.</p>
</div>
<div class="paragraph">
<p>Co zde chybí pro úspěšné generování předávajících instrukcí je, že překladač potřebuje vidět i <strong>typy funkčních parametrů a typ návratové hodnoty</strong>. Poskytnutí těchto informací je úkolem <strong>deklarace funkce</strong>. V našem případě je nejjednodušší forma deklarace funkce <code>add</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int, int);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jak zajistit aby překladač <strong>viděl tuto deklaraci</strong> když překládá funkci <code>main</code>? Nejpřímočařejším řešením je jednoduše přidání deklarace do stejného zdrojového souboru:</p>
</div>
<div class="listingblock">
<div class="title">main2.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nyní, překlad pomocí <code>g&#43;&#43; -O2 -c main2.cpp</code> uspěl a&#8201;&#8212;&#8201;v mém případě&#8201;&#8212;&#8201;jsem obdržel následující instrukce vygenerované pro funkci <code>main</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">sub  rsp, 8
mov  esi, 2
mov  edi, 1
call add(int, int)
add  rsp, 8
add  eax, 3
ret</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Aplikační binární rozhraní (ABI)</div>
<div class="paragraph">
<p>Na každém počítačovém systému musí existovat <strong>dohoda</strong> o tom, jak jsou předávány argumenty a návratové hodnoty do/z funkcí <strong>na úrovni strojového kódu</strong>. Tato dohoda je součástí něčeho, čemu se říká <strong>aplikační binární rozhraní <em>(application binary interface; ABI)</em></strong>. Bez ABI by části strojového kódu vygenerované například rozdílnými překladači nebyly schopny spolupracovat.</p>
</div>
<div class="paragraph">
<p>Na mém systému ABI předepisuje, že hodnoty argumentů jsou do funkce, která má dva parametry typu <code>int</code>, předávány přes registry procesoru <code>edi</code> a <code>esi</code>. Protože u našeho volání funkce <code>add</code> mají argumenty hodnoty 1 a 2, jsou přiřazeny těmto registrům. ABI dále předepisuje, že návratová hodnota typu <code>int</code> je předána z funkce přes registr <code>eax</code>. Povšimněme si, že toto platí pro obě funkce <code>add</code> a <code>main</code>. Podle zdrojového kódu je hodnota navrácená z funkce <code>add</code> inkrementována o 3 a vrácena z funkce <code>main</code>. Na úrovni strojového kódu tento efekt zajistí inkrement registru <code>eax</code> o 3.</p>
</div>
<div class="paragraph">
<p>Nakonec, proč jsou zde ony dvě instrukce, které manipulují s registrem ukazatele zásobníku <em>(stack pointer)</em> <code>rsp</code>? Důvod rovněž souvisí s použitým ABI. To totiž předepisuje, že při spuštění instrukce <code>call</code> musí být <code>rsp</code> zarovnáno na 16 bytovou adresu. Toto platí při volání funkce <code>main</code>, ale odpovídající instrukce <code>call</code> sníží hodnotu <code>rsp</code> o 8 (díky uložení aktuální hodnoty instrukčního ukazatele <em>(instruction pointer)</em> <code>rip</code> na zásobník). Pro zajištění 16 bytového zarovnání <code>rsp</code> před voláním <code>call add</code> uvnitř <code>main</code> je tedy potřeba snížít hodnotu <code>rsp</code> ještě jednou (<code>sub rsp, 8</code>). Po návratu z funkce <code>add</code> je tento efekt invertován instrukcí <code>add rsp, 8</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Nyní jsme tedy schopni přeložit zdrojový kód souboru <code>main2.cpp</code> na strojový kód. Nicméně tento strojový kód <strong>zatím ještě není ve formě spustitelného programu</strong>. Díky přepínači <code>-c</code> použitého pro překladač <code>g&#43;&#43;</code> má zatím formu tzv. <strong>objektového souboru <em>(object file)</em></strong>, který má implicitně název <code>main2.o</code>.</p>
</div>
<div class="paragraph">
<p>Pro sestavení spustitelného programu musejí být všechny výskyty instrukce <code>call</code> <strong>spojeny</strong> <em>(link)</em> se strojovým kódem volaných funkcí. Toto je úkolem nástroje implementace C&#43;&#43; nazvaného <strong><em>linker</em></strong>. V mém případě je linker program nazvaný <code>ld</code>, který interně využívá <code>g&#43;&#43;</code> v případě, že na vstupu dostane objektový soubor.</p>
</div>
<div class="paragraph">
<p>S mojí implementací založené na <code>g&#43;&#43;</code> máme nyní dvě možnosti jak sestavit spustitelný program pro <code>main2.cpp</code>. Ta první je, že <strong>odděleně přeložíme</strong> tento zdrojový soubor pomocí</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="plaintext" class="language-plaintext hljs">g++ -O2 -c main2.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>a výsledný <code>main2.o</code> <strong>spojíme</strong> do spustitelného programu příkazem</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="plaintext" class="language-plaintext hljs">g++ main2.o</code></pre>
</div>
</div>
<div class="paragraph">
<p>Druhá možnost je, že <strong>oba kroky sloučíme dohromady do jednoho příkazu:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="plaintext" class="language-plaintext hljs">g++ -O2 main2.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>který interně provede totéž (pouze bez explicitního uložení souboru <code>main2.o</code>).</p>
</div>
<div class="paragraph">
<p>V mém případě obě tyto možnosti vedly na následující <strong>chybu</strong>, kterou reportoval linker <code>ld</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="plaintext" class="language-plaintext hljs">undefined reference to `add(int, int)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Příčina této chyby (jedné z vůbec nejčastějších při programování v C&#43;&#43;) je zřejmá&#8201;&#8212;&#8201;linker vidí instrukci <code>call</code> pro volání funkce <code>add</code>, ale nevidí žádný strojový kód této funkce, s kterým by ono <strong>volání mohl spojit</strong>.</p>
</div>
<div class="paragraph">
<p>Jak tedy poskytnout tento zdrojový kód? Překladač ho samozřejmě nemůže vygenerovat jen na základě deklarace funkce <code>add</code>. Místo toho potřebuje vidět <strong>tělo funkce</strong>, které zpřístupňuje její <strong>definice</strong>. V našem případě tato definice vypadá následovně:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int a, int b)
{
  return a + b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obecně platí, že definice funkce <strong>instruuje překladač aby vygeneroval její strojový kód</strong>. Dejme pro začátek tuto definici funkce <code>add</code> do samostatného zdrojového souboru:</p>
</div>
<div class="listingblock">
<div class="title">add.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int a, int b)
{
  return a + b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nyní můžeme vygenerovat strojový kód funkce <code>add</code> ve formě objektového souboru <code>add.o</code> příkazem <code>g&#43;&#43; -O2 -c add.cpp</code>. Generované instrukce pro funkci byly v mém případě tyto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">lea eax, [rdi+rsi]
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instrukce <code>lea</code> sečte hodnoty argumentů funkce&#8201;&#8212;&#8201;předané pomocí registrů <code>edi</code> a <code>esi</code> (na hodnotě vyšších 32 bitů registrů <code>rdi</code> a <code>rsi</code> nezáleží)&#8201;&#8212;&#8201;a výsledek uloží do registru <code>eax</code>. Tento registr je poté použit pro předání výsledku na místo volání funkce.</p>
</div>
<div class="paragraph">
<p>Nyní konečně máme vše, co je potřeba pro sestavení <strong>spustitelného programového souboru</strong>. Uvnitř <code>main2.o</code> je volání funkce <code>add</code>. Uvnitř <code>add.o</code> je její strojový kód. Příkaz <code>g&#43;&#43; main2.o add.o</code> předá oba soubory linkeru a ten vygeneruje spustitelný soubor s výchozím názvem <code>a.out</code>.</p>
</div>
<div class="paragraph">
<p>Mimochodem, <code>g&#43;&#43;</code> nám umožňuje sloučit překlad obou zdrojových souborů a spojení výsledných objektových souborů do jednoho příkazu: <code>g&#43;&#43; -O2 main2.cpp add.cpp</code>. V mém případě byl výsledný spustitelný soubor úplně stejný.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Souhrn</div>
<div class="ulist">
<ul>
<li>
<p><strong>Deklarace funkce</strong> instruuje překladač jak má <strong>generovat strojový kód pro volání této funkce</strong>.</p>
</li>
<li>
<p><strong>Definice funkce</strong> instruuje překladač aby vygeneroval její <strong>strojový kód</strong> (strojový kód pro její tělo).</p>
</li>
<li>
<p>Pro sestavení spustitelného programu musí být instrukce volání funkce <strong>spojeny</strong> se strojovým kódem těchto funkcí, což je úkolem nástroje zvaného <strong>linker</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "cs";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;všechna práva vyhrazena.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>