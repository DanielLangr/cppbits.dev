= Trochu jiný {cpp} tutoriál
Daniel Langr <daniel.langr@gmail.com>
//:revdate: {docdate}
:rootdir: .
include::{rootdir}/include/attributes.adoc[]

[.normal]
Cílem těchto stránek je vytvořit *výukový materiál pro programování v {cpp}*. Takového materiálu sice existuje nepřeberné množství, ale já bych se rád zaměřil na *témata, která se úplně běžně neprobírají*. A přesto jsou podle mého názoru pro pochopení fylozofie {cpp} naprosto klíčová.

Důvodem programování v {cpp} je především požadavek na *vysoký výkon a efektivitu programů*. Tím je myšleno, že programy běží co nejrychleji a spotřebovávají minimální množství systémových prostředků, jako je čas procesoru či množství alokované paměti. Pro dosažení tohoto cíle ale často nestačí pohybovat se jen na úrovni zdrojového kódu. Je potřeba se podívat, co se děje „uvnitř“ na úrovni *strojového kódu*, který ze zdrojového kódu vygeneruje {cpp} překladač.

Jednoduchý příklad -- v každém materiálu pro začátečníky se dočteme, jak ve funcki vytvořit *lokální proměnnou* (přesněji řečeno nestatickou proměnnou s automatickou životností). Běžná představa je, že takováto proměnná bude při behu programu uložena na *zásobníku*. Je to ale pravda? Může místo toho být proměnná uložena v *registru procesoru*? Musí tato proměnná za běhu programu *vůbec existovat*? Jaké faktory o tom rozhodují? A co když je to proměnná *třídního typu*? Co vůbec znamená vytvoření proměnné třídního typu pomocí *konstruktoru*? Zdánlivě triviální problematika na úrovni zdrojového kódu v sobě skrývá vysoce netriviální problematiku na úrovni strojového kódu, který procesor vykonává v době běhu programu.

Zde jsou příklady dalších témat, která nejsou zcela běžně diskutována ve výukových materiálech a přesto může být velmi podstatné jim rozumět:

****
- Co je to *implementace {cpp}*? Jak se od sebe jednotlivé implementace liší?
- Jaký je rozdíl mezi velikostí objektů z hlediska *obsahu* a velikostí jejich *bitové reprezentace*?
- Proč existuje *_padding_* a jak souvisí se *zarovnáním* bitové reprezetnace objektů v paměti?
- Proč nelze oddělit *API* třídy od všech jejích *implementačních detailů*?
- Jak je v praxi zajištěno *předávání argumentů a návratových hodnot* do/z funkcí?
- Co je to *ABI* a jak zajistit *kompatabilitu* na této úrovni?
- Co jsou to *jednotky překladu*? Jak souvisí s problematikou *_linkage_*? 
- Proč specifikátor `inline` *nesouvisí* s „inlinováním“ funkcí?
- Proč nelze z vygenrovaného strojového kódu programu *zpětně zjistit jeho zdrojový kód*?
- Co je to *nedefinované chování*? Pokud má program nedefinované chování podle Standardu {cpp}, má nedefinované chování i vygenerovaný strojový kód?
- Proč v paměti nelze *přesunout objekt* z jednoho místa na druhé?
- Proč funkce `std::move` nic nikam nepřesouvá a funkce `std::forward` nic nikam nepředává, jakkoliv to jejich názvy napovídají?
****

Účelem tohoto blogu je *témata tohoto typu rozebírat a vysvětlovat*. Vycházím zde především z dlouhobé zkušenosti s aktivním působením na link:https://stackoverflow.com/[Stack Overflow] ohledně dotazů týkajících se {cpp} a také s výukou pokročilého programování v {cpp} na Fakultě informačních technologií ČVUT. V neposlední řadě se podílím na vývoji programů, které jsou spouštěny na největších světových superpočítačích, jejichž procesorový čas je nesmírně drahý a vzácný. Výkon a efektivita zde hrají primární roli, protože při spuštění na několika stech tisících procesorových jádrech se i zdánlivě zanedbatelný zdroj neefiktivity může projevit jako úzké hrdlo běhu programu.

TBD...
//Není určen pro úplné začátečníky. Respektive, není sám o sobě určen pro začátečníky. 

== Obsah

link:posts/01_asif.html[01: _As-if_ pravidlo] _(říjen 2020)_

== O autorovi

TBD...

include::{rootdir}/include/copyright.adoc[]
include::{rootdir}/include/disqus.adoc[]
