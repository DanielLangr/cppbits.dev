= 01: Introductory Example
Daniel Langr
//Daniel Langr <daniel.langr@outlook.com>
//:revdate: {docdate}
:revdate: January 2025
//:revremark: last modification
:rootdir: ../..
include::{rootdir}/include/attributes.adoc[]
//:description: 

[.normal]
_This is a part of the mini-series link:./index.html[Move Semantics Explained]._

Consider a variable `s` of type `std::string`, whose value is some string of characters. Suppose we now want to create another variable `s2` of type `std::string` that should contain the same value as `s`.

[source]
----
std::string s("orange");
// The value of 's' is "orange".

// How do we define 's2' so that it will have the same value as 's'?
----

To achieve that, we need to “intialize `s2` by `s`”. To be more precise, the expression that initializes `s2` needs to refer to `s`. 

[source]
----
std::string s2( /* expression referring to 's' */ );
// => The value of 's2' is "orange".
----

The question now is how this expression should look like. To answer this, we first need to ask another question:

IMPORTANT: What should happen to the value of `s`?

There are two possible answers:

. We need the value of `s` to be preserved.
. We don't need the value of `s` to be preserved.

If the first option applies, the initialization expression can be simply `s` itself:

[source]
----
// The value of 's' is "orange".
std::string s2(s);
// The value of 's' is "orange".
----

If the second options applies, the initialization expression typically used is `std::move(s)`:

[source]
----
// The value of 's' is "orange".
std::string s2(std::move(s));
// The value of 's' does not need to be "orange".
----

What have these expressions in common? They both refer to variable `s`. This guarantees that `s2` will have the same value as `s` originally had.

[source]
----
// The value of 's' is "orange".
std::string s2(s); // 's' refers to 's'
// => The value of 's2' is "orange".
----

[source]
----
// The value of 's' is "orange".
std::string s2(std::move(s)); // 'std::move(s)' refers to 's'
// => The value of 's2' is "orange".
----

What is the difference between both these cases? They differ in which constructor of `std::string` is called for initialization of `s2`:

. The initialization expression `s` causes the _copy constructor_ of `std::string` to be called.
. The initialization expression `std::move(s)` causes the _move constructor_ of `std::string` to be called. 

[source]
----
std::string s2(s); // 's2' is initialized by copy constructor of 'std::string'.
----

[source]
----
std::string s2(std::move(s)); // 's2' is intialized by move constructor of 'std::string'.
----

Both of them set the value of constructed `s2` to the value of `s`; however:

. The copy constructor guarantees that the value of `s` is preserved.
. The move constructor is free not to preserve the value of `s`.

When we put it all together:

[source]
----
// The value of 's' is "orange".
std::string s2(s); // 's2' is initialized by copy constructor of 'std::string'.
// => The value of 's2' is "orange".
// => The value of 's' is "orange".
----

[source]
----
// The value of 's' is "orange".
std::string s2(std::move(s)); // 's2' is intialized by move constructor of 'std::string'.
// => The value of 's2' is "orange".
// => The value of 's' does not need to be "orange".
----






include::{rootdir}/include/copyright.adoc[]
