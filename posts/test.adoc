= Jak {cpp} funguje?
Daniel Langr <daniel.langr@gmail.com>
:revdate: {docdate}
:lang: cs
:nofooter:
:linkcss:
:stylesdir: ../stylesheets/
:stylesheet: ubuntu-custom.css
:favicon: ../favicon/favicon.png
:icons: font
//:source-highlighter: coderay
:source-highlighter: highlightjs
:highlightjs-theme: agate
//:toc: left
//:toc-title: Obsah
//:source-highlighter: prettify
:source-language: c++
:stem: 

//[{docdate}]

//"`__Writing in C or {cpp} is like running a chain saw with all the safety guards removed.__`" _[Bob Gray]_
"`__Every time I write a line of code in {cpp} I check the assembly output to make sure it's running at optimal speed. I profile everything and also I have no friends.__`" _[Cole Rowland]_

{cpp} je tzv. „kompilovaný jazyk“ (_compiled language_), tj. programovací jazyk fungující na principu *překladu zdrojového kódu na strojový kód*. Nejjednodušší zdrojový kód programu vypadá v {cpp} následovně:

.main.cpp
[source]
----
int main() { }
----

Jeho překladem pomocí {cpp} překladače, např. následujícím způsobem:

[source,bash]
----
g++ main.cpp
----

vznikne *program* spustitelný na daném počítačovém systému. Spuštěním tohoto programu vznikne jeho běžící instance -- *proces* operačního systému. Ten začne vykonávat překladačem vygenerovaný strojový kód, tedy *instrukce procesoru*. V mém případě architektury x86_64 a operačního systému Linux měly následující podobu:

[source,x86asm]
----
push rbp
mov  rbp, rsp
mov  eax, 0
pop  rbp
ret
----

Chování programu definuje *Standard {cpp}*. Otázkou je, co si vlastně pod pojmem *chováním programu* představit. Jednoduše řečeno je to *pozorovatelný efekt programu* z pohledu jeho okolí.

Co o chování našeho programu říká Standard {cpp}? Od {cpp}11 je opuštění funkce `main` mimo příkaz `return` ekvivaletní příkazu `return 0;`. V takovém případě je zavolána funkce `std::exit` s argumentem `0`. To způsobí *normální ukončení programu s návratovým statusem 0*, což představuje jediný pozorovatelný efekt tohoto programu. 

{cpp} standard definuje chování programu na *abstraktním počítači*. Na *konkrétním počítačovém systému* toto chování zajišťuje tzv. *implementace {cpp}*. V našem případě tuto implementaci představuje již zmíněný překladač `g++`.

Jedním z nejdůležitějších konceptů {cpp} je tzv. *_as-if_ pravidlo* (_as-if rule_). To říká, že {cpp} implementace musí zajisit pouze pozorovatelné chování programu, ale *jak* tohoto chování docílí nechává zcela na ní. A jelikož důvodem programování v {cpp} je většinou hlavně *vysoký výkon a efektivita* vytvářených programů (či knihoven), implementace se snaží pozorovatelné chování zajistit právě s tímto ohledem. Alespoň, pokud zapneme *optimalizace*.

Výše ukázaný překlad proběhl s vypnutými optimalizacemi. Proto se ve vygenerovaném strojovém kódu objevily instrukce, které pozorovatelnému efektu programu nijak nepřispívají. Konkréntě to jsou instrukce pracující s registry zásobníku `rbp` a `rsp`. V případě překladu se zapnutými optimalizacemi:

[source,bash]
----
g++ -O2 main.cpp
----

se vygenerovaný strojový kód změnil na:

[source,x86asm]
----
xor  eax, eax
ret
----

Ten totiž pozorovatelné chování programu -- normální ukončení programu s návratovým statusem 0 -- zajišťuje *nejúspornějším způsobem*. Podle pravidel operačního systému je totiž návratový status programu předán v registru `eax`.

****
Proč je instrukce `xor eax, eax` efektivnější než `mov eax, 0`? Operační kód (_opcode_) té druhé je totiž `b8 00 00 00 00`, zatímco té první `32 c0`, a tedy podstatně kratší. To v praxi šetří množství přenesených dat mezi oprační pamětí a procesorem a zvyšuje efektivitu práce s instrukční cache pamětí.
****

Pokud nyní přepíšeme zdrojový soubor na:

.main1.cpp
[source]
----
int main()
{
  return 1;
}
----

tak překladač již vygeneruje instrukci `mov`:

[source,x86asm]
----
mov eax, 1
ret
----

Naprosto stejně dopadl vygenerovaný strojový kód pro následující zdrojový soubor:

.main2.cpp
[source]
----
int main()
{
  int i = 0;
  i++;
  return i;
}
----

A stejně tak pro:

.main3.cpp
[source]
----
class Int 
{
  int i_;
public:
  Int(int i) : i_(i) { }
  operator int&() { return i_; }
};

int main()
{
  Int i(0);
  i++;
  return i;
}
----

Pozorovatelné chování všech tří zdrojových souborů `main1.cpp`, `main2.cpp` i `main3.cpp` je totiž *totožné*. To má mimo jiné důsledek, že z přeloženého strojového kódu samotného nelze zjistit, z jakého zdrojového kódu byl vytvořen.

Co přesně tvoří pozorovatelný efekt programu nemusí být vždy úplně jasné. Vezměme v úvahu následující zdrojový kód:

[source]
----
int main()
{
  int* pi = new int(0);
  delete pi;
}
----

Zdánlivě má tento program stejné pozorovatelné chování jako `main.cpp`, tedy pouze ukončení programu s návratovým statusem 0. Na druhou stranu zde dochází k dynamické alokaci paměti a ta může být z okolí programu rovněž pozorovatelná, např. pomocí profilovacích nástorjů haldy jako jsou Valgrind nebo Heaptrack. O tom, zda mohou být dynamické alokace eliminovány v rámci optimalizací se vedly a vedou diskuze. Novější implementace tuto optimalizaci umožňují -- například `g++` se tímto způsobem v mých experimentech chovalo od verze 10.1. Starší verze vygenerovaly strojový kód s volání alokační a dealokační funkce.
 
****
_As-if_ pravidlo je důležité pro psaní benchmarků, tj. programů, kde se snažíme změřit dobu běhu nějaké operace. V takovém případě je nutné zajistit, aby tato opearce měla pozorovatelný efekt, jinak ji překladač může v rámci optimalizací eliminovat a benchmark poté bude dávat nesmyslné výsledky.
****

//stem:[E=mc^2], stem:[e^{i\pi}+1=0]

'''
include::../include/disqus.adoc[]

****
[.text-center]
(C) 2020 Daniel Langr -- všechna práva vyhrazena.
****
