= 01: As-if rule
Daniel Langr <daniel.langr@gmail.com>
//:revdate: {docdate}
:revdate: November 2020
//:revremark: last modification
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: The goal of a {cpp} implementation is to provide such observable program behavior that is defined for it by the {cpp} standard.

[.normal]
link:../../cs/posts/01_asif.html[Česká verze] image:https://www.countryflags.io/cz/shiny/24.png[Česká verze, link="../../cs/posts/01_asif.html"] +
link:../index.html[Homepage] image:up.png[link="../index.html"] 

''''

[quote, Cole Rowland]
____
Every time I write a line of code in {cpp} I check the assembly output to make sure it's running at optimal speed. I profile everything and also I have no friends.
____

{cpp} is a so-called “compiled language”, that is, a programming language based on a principle of *compiling source code to machine code*. The simplest {cpp} source code looks as follows:

.main.cpp
[source]
----
int main() { }
----

If we compile it with a {cpp} compiler, for instance, this way:

[source,bash]
----
g++ main.cpp
----

a *program* executable on a given computer system is generated. By running this program, its instance -- an operating system *process* -- is created, which starts executing the machine code / *processor instructions* generated by the compiler. In my case of the x86_64 architecture and the Linux operating system, these instructions looked as follows:

[source,x86asm]
----
push rbp
mov  rbp, rsp
mov  eax, 0
pop  rbp
ret
----

.Machine code vs. assembler
****
Machine code consists of *binary data* that is hardly readable in practice. For the purpose of its inspection, it is thus usually translated into corresponding *assembler instructions* by software called _disassembler_. An exemplary disassembler is the `objdump` program run with the command line option `-d`/`--disassemble`.

An outstanding tool for inspecting machine code generated for some particular source code is the *online* {cpp} compiler and disassembler link:https://godbolt.org/[Compiler Explorer]. It provides a large number of *{cpp} compilers* from different vendors and also several target *processor architectures*.
****

The behavior of a program is defined according to its source code by the *{cpp} standard*. But what is *program behavior*? Simply said, it is the *observable effect of the program* from the perspective of its surroundings.

What does the {cpp} standard say about the behavior of our program? Since {cpp}11, leaving the `main` function without explicit `return` call is equivalent to `return 0;`. It causes *normal program termination with exit status 0*, and this makes its only observable effect.

The {cpp} standard defines how a program should behave on an *abstract machine*. On a *particular computer system*, this behavior is rendered by a *{cpp} implementation* (represented by the `g++` compiler in our case). One of the most important {cpp} concepts is the so-called *as-if rule*. It says that the implementation shall render only the observable program behavior, but *how* it is achieved is purely a matter of the implementation itself. Implementations then under optimizations try to render the observable behavior with respect to *maximizing performance and efficiency*.

The above-shown compilation was carried out with *disabled optimizations*. This yielded, in the generated machine code, instructions that do not contribute in any way to the observable program behavior. Namely, these are the instructions working with the `rbp` and `rsp` stack registers. In case of *enabled optimizations*:

[source,bash]
----
g++ -O2 main.cpp
----

the generated machine code has turned to:

[source,x86asm]
----
xor  eax, eax
ret
----

On the used computer system, the exit status was returned from the `main` function through the `eax` register. These instructions then render the observable program behavior -- normal program termination with exit status 0 -- with *minimal effort*.

.Why is `xor eax, eax` more efficient than `mov eax, 0`?
****
The binary form of the machine code -- so-called _opcode_ -- of the instructions `mov eax, 0` and `xor eax, eax` is `b8 00 00 00 00` a `32 c0`, respectively. In the second case, it is considerably *shorter*. This, in practice, reduces the amount of data transferred between memory and a processor and increases the utilization of the instruction cache.
****

Now, when I rewrote the source code to:

.main1.cpp
[source]
----
int main()
{
  return 1;
}
----

the compiler already generated the `mov` instruction:

[source,x86asm]
----
mov eax, 1
ret
----

The very same machine code was generated for the following source code:

.main2.cpp
[source]
----
int main()
{
  int i = 0;
  i++;
  return i;
}
----

As well as for:

.main3.cpp
[source]
----
class Int 
{
  int i_;
public:
  Int(int i) : i_(i) { }
  operator int&() { return i_; }
};

int main()
{
  Int i(0);
  i++;
  return i;
}
----

That was because the observable behavior defined by the standard for all the three source code files `main1.cpp`, `main2.cpp`, and `main3.cpp` is *identical*. This, by the way, implies that it is *not possible* for some machine code to *find out* from which source code it has been generated. With enabled optimizations, there is even no direct correspondence between particular source code statements and generated machine code instructions (for such purposes, it is necessary to add debugging information).

What exactly is considered to be an observable program effect *may not always be entirely clear*. Let us look at the following source code:

[source]
----
int main()
{
  int* pi = new int(0);
  delete pi;
}
----

Seemingly, this program has the same observable behavior as `main.cpp`, which is the normal program termination with the exit status 0. However, there is that dynamic memory allocation, which also may be *observable*, for example, by heap profiling tools such as _Valgrind_ or _Heaptrack_. There have been discussions in the {cpp} community about whether dynamic memory allocations may or may not be optimized away by compilers. Recent implementations do apply this optimization -- for instance, `g++` since version 10 in my experiments. Older versions generated machine code with calls of memory allocation and deallocation functions.

.Benchmarks
****
The as-if rule is important for creating *benchmarks* -- programs where *the running time of some operation is measured*. It is necessary to guarantee that the measured operation has some observable effect. Otherwise, a compiler could optimize it away, and the benchmark would yield irrelevant results. For instance, the _Google/Benchmark_ framework addresses this problem with the `benchmark::DoNotOptimize` special function.
****

.Summary
****
- {cpp} is based on the *translation of source code to processor machine code*.
- A {cpp} implementation guarantees that the generated machine code yields, on a given computer system, the *observable behavior* defined for its source code by the {cpp} standard.
- If optimizations are enabled, compilers try to generate machine code that will render the prescribed observable behavior *in the most efficient way*.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
