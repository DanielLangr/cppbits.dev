<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="The goal of a C&#43;&#43; implementation is to provide, on a particular computer system, the observable behavior of a program defined for its source code by the C&#43;&#43; standard.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../../favicon/favicon.png">
<title>02: C&#43;&#43; implementation</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>02: C&#43;&#43; implementation</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">November 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../../cs/posts/02_implementace.html">Česká verze</a> <span class="image"><a class="image" href="../../cs/posts/02_implementace.html"><img src="https://www.countryflags.io/cz/shiny/24.png" alt="Česká verze"></a></span><br>
<a href="../index.html">Homepage</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>There are only two things wrong with C&#43;&#43;: The initial concept and the implementation.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bertrand Meyer
</div>
</div>
<div class="paragraph">
<p>As already said, a <strong>C&#43;&#43; implementation</strong> guarantees that a program executed on the particular computer system has the observable behavior prescribed to it by the C&#43;&#43; standard according to its source code. A C&#43;&#43; implementation consists mainly of a <strong>C&#43;&#43; compiler</strong>. If not written otherwise, under this term, we will&#8201;&#8212;&#8201;for the sake of simplicity&#8201;&#8212;&#8201;consider the whole set of tools needed for <strong>generating an executable program or library file from its source code</strong>. Next to the machine code “generator” itself, this set will thus include also tools such as a <em>preprocessor</em> or a <em>linker</em>.</p>
</div>
<div class="paragraph">
<p>However, a compiler itself is not sufficient for implementing C&#43;&#43; on a particular computer system. The C&#43;&#43; standard consists of two main parts. The first one describes the <strong>programming language</strong>, such as data types and operations with them, functions, classes, templates, etc. The second&#8201;&#8212;&#8201;and much larger&#8201;&#8212;&#8201;part (more than twice in the current standard draft) deals with the <strong>C&#43;&#43; standard library</strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">C&#43;&#43; standard library vs. STL</div>
<div class="paragraph">
<p>The C&#43;&#43; standard library is sometimes called <strong>STL</strong>, which is an abbreviation of the <strong>standard template library</strong>. Some people use this term only for the part of the C&#43;&#43; standard library that involves algorithms, containers, and iterators. In theory, using the STL term is <strong>incorrect</strong>&#8201;&#8212;&#8201;there is no occurrence of it in the standard. However, it has been <strong>widely adopted in practice</strong>. For instance, Microsoft calls the GitHub repository with its C&#43;&#43; standard library implementation <em>microsoft/STL</em>, and Intel calls its parallel version of the C&#43;&#43; standard library <em>Parallel STL</em>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Basically, the first part of the standard describes everything that is needed to write source code that <strong>does not include any C&#43;&#43; standard library header file</strong>. (There are rare exceptions&#8201;&#8212;&#8201;for example the allocation function <code>::operator new</code> provided by the <code>&lt;new&gt;</code> header file.) An example of such code is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  return 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To generate a binary executable program from this source code, only a C&#43;&#43; compiler itself is needed. However, the same will not hold for the following source code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">#include &lt;iostream&gt;

int main()
{
  std::cout &lt;&lt; 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To generate an executable program and, eventually, to run it (in case of dynamic linking), an <strong>implementation of a C&#43;&#43; standard library</strong> is needed as well. In practice, the three <strong>most common implementations</strong>&#8201;&#8212;&#8201;at least on the x86_64 architecture&#8201;&#8212;&#8201;are <em>libstdc&#43;&#43;</em> provided by <em>GNU</em>, <em>libc&#43;&#43;</em> provided by <em>LLVM</em>, and already mentioned <em>Microsoft STL</em>.</p>
</div>
<div class="paragraph">
<p>Some compilers are able to work with different standard library implementations&#8201;&#8212;&#8201;such as Clang with both <em>libstdc&#43;&#43;</em> and <em>libc&#43;&#43;</em>. The default choice is given by the installation and system. On Linux, <em>Clang</em> will mostly use <em>libstdc&#43;&#43;</em> by default, while it will be <em>libc&#43;&#43;</em> on Mac OS X. However, most compilers are relatively <strong>tightly bound</strong> to a particular standard library implementation. For instance, compilers from GNU (GCC) and Intel use <em>libstdc&#43;&#43;</em>, the Microsoft&#8217;s compiler naturally uses the Microsoft STL.</p>
</div>
<div class="paragraph">
<p>A large portion of the C&#43;&#43; standard library consists of <strong>templates</strong>. Their source code must be “visible” during compilation and, consequently, it can be found within implementations in the form of <strong>header files</strong>. Moreover, the <strong>complete source code</strong> of the above-mentioned implementations is available in <strong>GitHub repositories</strong>, namely:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>libstdc&#43;&#43;</em>: the repository <em>gcc-mirror/gcc</em>&#8201;&#8212;&#8201;subdirectory <a href="https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3"><em>libstdc&#43;&#43;-v3</em></a>,</p>
</li>
<li>
<p><em>libc&#43;&#43;</em>: the repository <em>llvm/llvm-project</em>&#8201;&#8212;&#8201;subdirectory <a href="https://github.com/llvm/llvm-project/tree/master/libcxx"><em>libcxx</em></a>,</p>
</li>
<li>
<p><em>Microsoft STL</em>: the repository <a href="https://github.com/microsoft/STL"><em>microsoft/STL</em></a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This source code makes a valuable <strong>material for learning</strong>. These implementations have been developed with a focus on high performance, and they are tested and verified by a large number of programmers and their programs on a daily basis. On the other side, their code is very complex and it may not be easy to get familiar with it.</p>
</div>
<div class="paragraph">
<p>Exploration of the source code can also be useful when we want to understand why the implementation <strong>behaves in some particular way</strong>. For example&#8201;&#8212;&#8201;all the three mentioned C&#43;&#43; standard library implementations apply for <code>std::string</code> an optimization technique called <strong>small (short) string optimization (SSO)</strong>. The effect of this optimization is that the storage of strings <strong>up to some length</strong> does not require dynamic memory allocations. Instead, the characters are stored <strong>inside the memory representation of the class object itself</strong>.</p>
</div>
<div class="paragraph">
<p>The “short” string limit depends on the way <strong>how</strong> SSO is implemented. We may find this limit by reading the “capacity” of an empty <code>std::string</code> object. Meanwhile, let us also look at the <strong>byte size of its memory representation</strong>, which may be obtained by the <code>sizeof</code> operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  std::string s;
  std::cout &lt;&lt; s.capacity() &lt;&lt; std::endl;
  std::cout &lt;&lt; sizeof s &lt;&lt; std::endl;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the x86_64 architecture, I got the <strong>capacity 15 and size 32</strong> with <em>libstdc&#43;&#43;</em> and the <em>Microsoft STL</em>, while the <strong>capacity 22 and size 24</strong> with <em>libc&#43;&#43;</em>. Seemingly, <em>libc&#43;&#43;</em> is much more efficient&#8201;&#8212;&#8201;it can store, without dynamic memory allocation&#8201;&#8212;&#8201;a string of up to 22 characters in 24 bytes, while the other two implementations can store into 32 bytes only up to 15 characters.</p>
</div>
<div class="paragraph">
<p>To understand the difference between implemented variants of SSO, it is necessary to look into the source code. A detailed analysis is beyond the scope of this article (hopefully, I will get back to it the future), but in short it can be said that <em>libc&#43;&#43;</em> <strong>prefers high memory efficiency at the price of reduced runtime efficiency</strong>. Namely, it needs to find out whether the stored string is short (up to 22 characters) or long every time it is accessed. Based on the result, it must <strong>derive the pointer to the stored characters</strong>, which represents some <strong>runtime overhead</strong>. On the contrary, in <em>libstdc&#43;&#43; and _Microsoft STL</em>, the <code>std::string</code> object has the pointer to the stored characters directly available in the form of a <strong>separate member variable</strong>. This approach reduces the memory efficiency, but increases the runtime one.</p>
</div>
<div class="paragraph">
<p>Another example is the following problem (this one may be <strong>not for beginners</strong>&#8201;&#8212;&#8201;if you do not understand it, simply skip it over):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">#include &lt;map&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

int main()
{
  std::vector&lt; std::map&lt;int, std::thread&gt; &gt; v;
  v.reserve(1);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In my case, this code was compiled without any problems by the C&#43;&#43; implementations that used <em>libstdc&#43;&#43;</em> or <em>libc&#43;&#43;</em>. But the compilation with <em>Microsoft STL</em> ended up <strong>with errors</strong>. Why did it happen? By inspecting the source code, we can find out that in <em>libstdc&#43;&#43;</em> and <em>libc&#43;&#43;</em>, the <strong>move constructor</strong> of <code>std::map&lt;int, std::thread&gt;</code> <strong>does not throw exceptions</strong>&#8201;&#8212;&#8201;it “is” so-called <strong>noexcept</strong> (to be correct, we should say that this constructor has a <em>non-throwing exception specification</em>). In <em>Microsoft STL</em>, this characteristics of the map type <strong>does not hold</strong>.</p>
</div>
<div class="paragraph">
<p>Move constructors that throw exceptions can generally <strong>cause troubles</strong>. In the <code>reserve</code> “reallocation” vector member function, such an exception may cause that, after the function call, the vector content will be <strong>different</strong> than it was before this call (so-called <em>strong exception guarantee</em> will not hold). The C&#43;&#43; standard therefore prescribes that the <code>reserve</code> member function must <strong>prefer copy constructor</strong> in such a case.</p>
</div>
<div class="paragraph">
<p>The last piece of the puzzle makes the fact that the <code>std::thread</code> objects are <strong>non-copyable</strong>. This, of course, implies that it is not possible to copy the content of any container that contains <code>std::thread</code> objects as well. In our case, this was the map <code>std::map&lt;int, std::thread&gt;</code>. In <em>Microsoft STL</em>, due to potentially-throwing map&#8217;s move constructor, <code>reserve</code> tries to call its copy constructor, which fails due to the impossibility to copy its elements.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Which implementation is right?</div>
<div class="paragraph">
<p>In the analyzed problem, the implementations <strong>behave differently</strong> at a level of successful/unsuccessful compilation of the same source code. We may naturally ask which implementation is the correct one? The answer is that <strong>all the three</strong>. The C&#43;&#43; standard <strong>does not request</strong> the move constructor of <code>std::map</code> class template to be noexcept. On the other side, it <strong>does not forbid</strong> it either.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Summary</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>C&#43;&#43; implementation</strong> ensures that a program running on some <strong>particular computer system</strong> has such <strong>observable behavior</strong> that is prescribed <strong>to its source code</strong> by the C&#43;&#43; standard.</p>
</li>
<li>
<p>It consists of a set of tools for the <strong>compilation</strong> of source code to the executable machine code (a preprocessor, compiler, linker, etc.) and an <strong>implementation of the C&#43;&#43; standard library</strong>.</p>
</li>
<li>
<p><strong>The most commonly used implementations</strong> of the C&#43;&#43; standard library are <em>libstdc&#43;&#43;</em>, <em>libc&#43;&#43;</em>, and <em>Microsoft STL</em>. Their source code is in all three cases <strong>publicly available</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "en";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;All rights reserved.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>