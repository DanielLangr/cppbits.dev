= 02: {cpp} implementation 
Daniel Langr <daniel.langr@gmail.com>
:revdate: říjen 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: 

[.normal]
link:../../cs/posts/02_implementace.html[Česká verze] image:https://www.countryflags.io/cz/shiny/24.png[Česká verze, link="../../cs/posts/02_implementace.html"] +
link:../index.html[Homepage] image:up.png[link="../index.html"] 

''''

[quote, Bertrand Meyer]
____
There are only two things wrong with {cpp}: The initial concept and the implementation.
____

As already said, a *{cpp} implementation* guarantees that a program executed on the particular computer system has the observable behavior prescribed to it by the {cpp} standard according to its source code. A {cpp} implementation consists mainly of a *{cpp} compiler*. If not written otherwise, under this term, we will -- for the sake of simplicity -- consider the whole set of tools needed for *generating an executable program or library file from its source code*. Next to the machine code “generator” itself, this set will thus include also tools such as a _preprocessor_ or a _linker_.

However, a compiler itself is not sufficient for implementing {cpp} on a particular computer system. The {cpp} standard consists of two main parts. The first one describes the *programming language*, such as data types and operations with them, functions, classes, templates, etc. The second -- and much larger -- part (more than twice in the current standard draft) deals with the *{cpp} standard library*.

.{cpp} standard library vs. STL
****
The {cpp} standard library is sometimes called *STL*, which is an abbreviation of the *standard template library*. Some people use this term only for the part of the {cpp} standard library that involves algorithms, containers, and iterators. In theory, using the STL term is *incorrect* -- there is no occurrence of it in the standard. However, it has been *widely adopted in practice*. For instance, Microsoft calls the GitHub repository with its {cpp} standard library implementation _microsoft/STL_, and Intel calls its parallel version of the {cpp} standard library _Parallel STL_.
****

Basically, the first part of the standard describes everything that is needed to write source code that *does not include any {cpp} standard library header file*. (There are rare exceptions -- for example the allocation function `::operator new` provided by the `<new>` header file.) An example of such code is as follows:

[source]
----
int main()
{
  return 1;
}
----

To generate a binary executable program from this source code, only a {cpp} compiler itself is needed. However, the same will not hold for the following source code:

[source]
----
#include <iostream>

int main()
{
  std::cout << 1;
}
----

To generate an executable program and, eventually, to run it (in case of dynamic linking), an *implementation of a {cpp} standard library* is needed as well. In practice, the three *most common implementations* -- at least on the x86_64 architecture -- are _libstdc{plus}{plus}_ provided by _GNU_, _libc{plus}{plus}_ provided by _LLVM_, and already mentioned _Microsoft STL_.

Some compilers are able to work with different standard library implementations -- such as Clang with both _libstdc{plus}{plus}_ and _libc{plus}{plus}_. The default choice is given by the installation and system. On Linux, _Clang_ will mostly use _libstdc{plus}{plus}_ by default, while it will be _libc{plus}{plus}_ on Mac OS X. However, most compilers are relatively *tightly bound* to a particular standard library implementation. For instance, compilers from GNU (GCC) and Intel use _libstdc{plus}{plus}_, the Microsoft's compiler naturally uses the Microsoft STL.

A large portion of the {cpp} standard library consists of *templates*. Their source code must be “visible” during compilation and, consequently, it can be found within implementations in the form of *header files*. Moreover, the *complete source code* of the above-mentioned implementations is available in *GitHub repositories*, namely:

- _libstdc{plus}{plus}_: the repository _gcc-mirror/gcc_ -- subdirectory link:https://github.com/gcc-mirror/gcc/tree/master/libstdc%2B%2B-v3[_libstdc{plus}{plus}-v3_],
- _libc{plus}{plus}_: the repository _llvm/llvm-project_ -- subdirectory link:https://github.com/llvm/llvm-project/tree/master/libcxx[_libcxx_],
- _Microsoft STL_: the repository link:https://github.com/microsoft/STL[_microsoft/STL_].

This source code makes a valuable *material for learning*. These implementations have been developed with a focus on high performance, and they are tested and verified by a large number of programmers and their programs on a daily basis. On the other side, their code is very complex and it may not be easy to get familiar with it.

Exploration of the source code can also be useful when we want to understand why the implementation *behaves in some particular way*. For example -- all the three mentioned {cpp} standard library implementations apply for `std::string` an optimization technique called *small (short) string optimization (SSO)*. The effect of this optimization is that the storage of strings *up to some length* does not require dynamic memory allocations. Instead, the characters are stored *inside the memory representation of the class object itself*. 

The “short” string limit depends on the way *how* SSO is implemented. We may find this limit by reading the “capacity” of an empty `std::string` object. Meanwhile, let us also look at the *byte size of its memory representation*, which may be obtained by the `sizeof` operator:

[source]
----
#include <iostream>
#include <string>

int main()
{
  std::string s;
  std::cout << s.capacity() << std::endl;
  std::cout << sizeof s << std::endl;
}
----

On the x86_64 architecture, I got the *capacity 15 and size 32* with _libstdc{plus}{plus}_ and the _Microsoft STL_, while the *capacity 22 and size 24* with _libc{plus}{plus}_. Seemingly, _libc{plus}{plus}_ is much more efficient -- it can store, without dynamic memory allocation -- a string of up to 22 characters in 24 bytes, while the other two implementations can store into 32 bytes only up to 15 characters.

To understand the difference between implemented variants of SSO, it is necessary to look into the source code. A detailed analysis is beyond the scope of this article (hopefully, I will get back to it the future), but in short it can be said that _libc{plus}{plus}_ *prefers high memory efficiency at the price of reduced runtime efficiency*. Namely, it needs to find out whether the stored string is short (up to 22 characters) or long every time it is accessed. Based on the result, it must *derive the pointer to the stored characters*, which represents some *runtime overhead*. On the contrary, in _libstdc{plus}{plus} and _Microsoft STL_, the `std::string` object has the pointer to the stored characters directly available in the form of a *separate member variable*. This approach reduces the memory efficiency, but increases the runtime one.

Another example is the following problem (this one may be *not for beginners* -- if you do not understand it, simply skip it over):

[source]
----
#include <map>
#include <thread>
#include <vector>

int main()
{
  std::vector< std::map<int, std::thread> > v;
  v.reserve(1);
}
----

In my case, this code was compiled without any problems by the {cpp} implementations that used _libstdc{plus}{plus}_ or _libc{plus}{plus}_. But the compilation with _Microsoft STL_ ended up *with errors*. Why did it happen? By inspecting the source code, we can find out that in _libstdc{plus}{plus}_ and _libc{plus}{plus}_, the *move constructor* of `std::map<int, std::thread>` *does not throw exceptions* -- it “is” so-called *noexcept* (to be correct, we should say that this constructor has a _non-throwing exception specification_). In _Microsoft STL_, this characteristics of the map type *does not hold*.

Move constructors that throw exceptions can generally *cause troubles*. In the `reserve` “reallocation” vector member function, such an exception may cause that, after the function call, the vector content will be *different* than it was before this call (so-called _strong exception guarantee_ will not hold). The {cpp} standard therefore prescribes that the `reserve` member function must *prefer copy constructor* in such a case.

The last piece of the puzzle makes the fact that the `std::thread` objects are *non-copyable*. This, of course, implies that it is not possible to copy the content of any container that contains `std::thread` objects as well. In our case, this was the map `std::map<int, std::thread>`. In _Microsoft STL_, due to potentially-throwing map's move constructor, `reserve` tries to call its copy constructor, which fails due to the impossibility to copy its elements.

.Which implementation is right?
****
In the analyzed problem, the implementations *behave differently* at a level of successful/unsuccessful compilation of the same source code. We may naturally ask which implementation is the correct one? The answer is that *all the three*. The {cpp} standard *does not request* the move constructor of `std::map` class template to be noexcept. On the other side, it *does not forbid* it either.
****

.Summary
****
- A *{cpp} implementation* ensures that a program running on some *particular computer system* has such *observable behavior* that is prescribed *to its source code* by the {cpp} standard.
- It consists of a set of tools for the *compilation* of source code to the executable machine code (a preprocessor, compiler, linker, etc.) and an *implementation of the {cpp} standard library*.
- *The most commonly used implementations* of the {cpp} standard library are _libstdc{plus}{plus}_, _libc{plus}{plus}_, and _Microsoft STL_. Their source code is in all three cases *publicly available*.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
