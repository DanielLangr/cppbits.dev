<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="The goal of a C&#43;&#43; implementation is to provide such observable program behavior that is defined for it by the C&#43;&#43; standard.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../favicon/favicon.png">
<title>01: As-if rule</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>01: As-if rule</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">November 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../../cs/posts/01_asif.html">Česká verze</a> <span class="image"><a class="image" href="../../cs/posts/01_asif.html"><img src="https://www.countryflags.io/cz/shiny/24.png" alt="Česká verze"></a></span><br>
<a href="../index.html">Homepage</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Every time I write a line of code in C&#43;&#43; I check the assembly output to make sure it&#8217;s running at optimal speed. I profile everything and also I have no friends.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Cole Rowland
</div>
</div>
<div class="paragraph">
<p>C&#43;&#43; is a so-called “compiled language”, that is, a programming language based on a principle of <strong>compiling source code to machine code</strong>. The simplest C&#43;&#43; source code looks as follows:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main() { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we compile it with a C&#43;&#43; compiler, for instance, this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">g++ main.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>a <strong>program</strong> executable on a given computer system is generated. By running this program, its instance&#8201;&#8212;&#8201;an operating system <strong>process</strong>&#8201;&#8212;&#8201;is created, which starts executing the machine code / <strong>processor instructions</strong> generated by the compiler. In my case of the x86_64 architecture and the Linux operating system, these instructions looked as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">push rbp
mov  rbp, rsp
mov  eax, 0
pop  rbp
ret</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Machine code vs. assembler</div>
<div class="paragraph">
<p>Machine code consists of <strong>binary data</strong> that is hardly readable in practice. For the purpose of its inspection, it is thus usually translated into corresponding <strong>assembler instructions</strong> by software called <em>disassembler</em>. An exemplary disassembler is the <code>objdump</code> program run with the command line option <code>-d</code>/<code>--disassemble</code>.</p>
</div>
<div class="paragraph">
<p>An outstanding tool for inspecting machine code generated for some particular source code is the <strong>online</strong> C&#43;&#43; compiler and disassembler <a href="https://godbolt.org/">Compiler Explorer</a>. It provides a large number of <strong>C&#43;&#43; compilers</strong> from different vendors and also several target <strong>processor architectures</strong>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The behavior of a program is defined according to its source code by the <strong>C&#43;&#43; standard</strong>. But what is <strong>program behavior</strong>? Simply said, it is the <strong>observable effect of the program</strong> from the perspective of its surroundings.</p>
</div>
<div class="paragraph">
<p>What does the C&#43;&#43; standard say about the behavior of our program? Since C&#43;&#43;11, leaving the <code>main</code> function without explicit <code>return</code> call is equivalent to <code>return 0;</code>. It causes <strong>normal program termination with exit status 0</strong>, and this makes its only observable effect.</p>
</div>
<div class="paragraph">
<p>The C&#43;&#43; standard defines how a program should behave on an <strong>abstract machine</strong>. On a <strong>particular computer system</strong>, this behavior is rendered by a <strong>C&#43;&#43; implementation</strong> (represented by the <code>g++</code> compiler in our case). One of the most important C&#43;&#43; concepts is the so-called <strong>as-if rule</strong>. It says that the implementation shall render only the observable program behavior, but <strong>how</strong> it is achieved is purely a matter of the implementation itself. Implementations then under optimizations try to render the observable behavior with respect to <strong>maximizing performance and efficiency</strong>.</p>
</div>
<div class="paragraph">
<p>The above-shown compilation was carried out with <strong>disabled optimizations</strong>. This yielded, in the generated machine code, instructions that do not contribute in any way to the observable program behavior. Namely, these are the instructions working with the <code>rbp</code> and <code>rsp</code> stack registers. In case of <strong>enabled optimizations</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">g++ -O2 main.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>the generated machine code has turned to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">xor  eax, eax
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the used computer system, the exit status was returned from the <code>main</code> function through the <code>eax</code> register. These instructions then render the observable program behavior&#8201;&#8212;&#8201;normal program termination with exit status 0&#8201;&#8212;&#8201;with <strong>minimal effort</strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Why is <code>xor eax, eax</code> more efficient than <code>mov eax, 0</code>?</div>
<div class="paragraph">
<p>The binary form of the machine code&#8201;&#8212;&#8201;so-called <em>opcode</em>&#8201;&#8212;&#8201;of the instructions <code>mov eax, 0</code> and <code>xor eax, eax</code> is <code>b8 00 00 00 00</code> a <code>32 c0</code>, respectively. In the second case, it is considerably <strong>shorter</strong>. This, in practice, reduces the amount of data transferred between memory and a processor and increases the utilization of the instruction cache.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Now, when I rewrote the source code to:</p>
</div>
<div class="listingblock">
<div class="title">main1.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  return 1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the compiler already generated the <code>mov</code> instruction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">mov eax, 1
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>The very same machine code was generated for the following source code:</p>
</div>
<div class="listingblock">
<div class="title">main2.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  int i = 0;
  i++;
  return i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As well as for:</p>
</div>
<div class="listingblock">
<div class="title">main3.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">class Int
{
  int i_;
public:
  Int(int i) : i_(i) { }
  operator int&amp;() { return i_; }
};

int main()
{
  Int i(0);
  i++;
  return i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That was because the observable behavior defined by the standard for all the three source code files <code>main1.cpp</code>, <code>main2.cpp</code>, and <code>main3.cpp</code> is <strong>identical</strong>. This, by the way, implies that it is <strong>not possible</strong> for some machine code to <strong>find out</strong> from which source code it has been generated. With enabled optimizations, there is even no direct correspondence between particular source code statements and generated machine code instructions (for such purposes, it is necessary to add debugging information).</p>
</div>
<div class="paragraph">
<p>What exactly is considered to be an observable program effect <strong>may not always be entirely clear</strong>. Let us look at the following source code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  int* pi = new int(0);
  delete pi;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Seemingly, this program has the same observable behavior as <code>main.cpp</code>, which is the normal program termination with the exit status 0. However, there is that dynamic memory allocation, which also may be <strong>observable</strong>, for example, by heap profiling tools such as <em>Valgrind</em> or <em>Heaptrack</em>. There have been discussions in the C&#43;&#43; community about whether dynamic memory allocations may or may not be optimized away by compilers. Recent implementations do apply this optimization&#8201;&#8212;&#8201;for instance, <code>g++</code> since version 10 in my experiments. Older versions generated machine code with calls of memory allocation and deallocation functions.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Benchmarks</div>
<div class="paragraph">
<p>The as-if rule is important for creating <strong>benchmarks</strong>&#8201;&#8212;&#8201;programs where <strong>the running time of some operation is measured</strong>. It is necessary to guarantee that the measured operation has some observable effect. Otherwise, a compiler could optimize it away, and the benchmark would yield irrelevant results. For instance, the <em>Google/Benchmark</em> framework addresses this problem with the <code>benchmark::DoNotOptimize</code> special function.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Summary</div>
<div class="ulist">
<ul>
<li>
<p>C&#43;&#43; is based on the <strong>translation of source code to processor machine code</strong>.</p>
</li>
<li>
<p>A C&#43;&#43; implementation guarantees that the generated machine code yields, on a given computer system, the <strong>observable behavior</strong> defined for its source code by the C&#43;&#43; standard.</p>
</li>
<li>
<p>If optimizations are enabled, compilers try to generate machine code that will render the prescribed observable behavior <strong>in the most efficient way</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "en";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;All rights reserved.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>