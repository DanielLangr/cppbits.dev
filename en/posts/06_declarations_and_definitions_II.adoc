= 06: Declarations and definitions II
Daniel Langr <daniel.langr@gmail.com>
:revdate: November 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: Declaration of some entity tells a compiler that it exists and how it can be used.

[.normal]
//link:../../cs/posts/05_deklarace_a_definice_II.html[Česká verze] image:https://www.countryflags.io/cz/shiny/24.png[Česká verze, link="../../cs/posts/05_deklarace_a_definice_II.html"] +
link:../index.html[Homepage] image:up.png[link="../index.html"] 

''''

[quote, Bjarne Stroustrup]
____
If you think it's simple, then you have misunderstood the problem.
____

Last time, we ended up with a program built from these *two source files*:

.main2.cpp
[source]
----
int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}
----

.add.cpp
[source]
----
int add(int a, int b)
{
  return a + b;
}
----

One of these files included the *declaration* of the `add` function plus its use (call), while the other included its *definition*. Of course, we could have also inserted this definition into the file with `main`, such as follows:

.main3.cpp
[source]
----
int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}

int add(int a, int b)
{
  return a + b;
}
----

*Is there any difference* between these two alternatives? The source code of both is *exactly the same*. Moreover, the same is also their *observable behavior*, which is the normal program termination with exit status 6. We may easily see it, but we are not important. What matters is *whether it can be “seen” by a compiler*?

For the *second alternative*, the answer is *yes*. A compiler can see all the code at once; therefore, it can derive its observable behavior and render it efficiently at a machine code level. For instance, with `g{plus}{plus} -O2 main3.cpp`, I got this minimal machine code for the `main` function:

[source,x86asm]
----
mov eax, 6
ret
----

.Inlining
****
One of the important compiler optimization techniques is function *inlining*. It works such that a call of a function is *virtually replaced* by its body. In our case, `int j = add(i, 2) + 3;` is virtually replaced by `int j = (i + 2) + 3;`.

Note that inlining has *no relation* to the `inline` specifier, which is kind-of misleading for beginners. There is no `inline` specifier in our code, and yet, `g{plus}{plus}` applied inlining under the `-O2` optimization option. `g++` also allows us to explicitly disable inlining with the `-fno-inline` command-line option. With `g{plus}{plus} -O2 -fno-inline main3.cpp`, we can generate a program that contains the machine code of the `add` function and its call from within `main`.
****

Let us now get back to the *first alternative* with two separate source files. Here, when compiling `main2.cpp`, a compiler sees the `add` function declaration plus its call, but does not know what the function performs in its body. Therefore, it has *no other option* than to generate a machine code with that call:

.main2.o
[source,x86asm]
----
sub  rsp, 8
mov  esi, 2
mov  edi, 1
call add(int, int)
add  rsp, 8
add  eax, 3
ret
----

Then, when compiling `add.cpp`, a compiler sees the definition of the `add` function, but has no clue of how this function is used. It has only *one option* -- to generate the function machine code:

.add.o
[source,x86asm]
----
lea eax, [rdi+rsi]
ret
----

Finally, a linker only *merges both pieces of machine code together* into an executable program file.

Comparing both alternatives, we ended up with *two executable programs* that both have the very same observable behavior. However, this behavior is, in both cases, *rendered very differently* at a machine code level. And, we do not have to be rocket scientists to guess which of these alternatives will be more efficient at runtime. Just in terms of instruction counts, the final score is 9–2.

.Link-time optimizations (LTO)
****
Inlining and other optimizations may be applied not only by a compiler. In theory, a linker may apply them -- at a machine code level -- as well. But, a linker is, well, primarily, just a linker. And, generally, optimizations are much easier to carry on when source code is available.

For example, the build tools related to both GCC and Clang enable *link-time optimizations (LTO)*. However, for their application, some additional information -- so-called _intermediate representation_ -- needs to be generated by a compiler and passed to a linker.
****

The question of whether the difference between the above-introduced alternatives matters *cannot be generally answered*. Usually, when a function performs *a lot of operations*, the effect of its inlining on the runtime performance will be negligible. The same will likely hold for a function that is called, at runtime, *only few times or even once*. Generally, inlining may be noticeable for *“short” functions that are called frequently*.

.Summary
****
- A compiler may generate much more optimized machine code, if it “sees” *both the function call and the definition of that function* at the same time.
- The application of function inlining *is not related* to the `inline` specifier.
- Inlining is especially important for *frequently-called functions that perform only few operations*.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
