<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="Declaration of some entity tells a compiler that it exists and how it can be used. Function definition tells a compiler to generate its machine code.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../../favicon/favicon.png">
<title>05: Declarations and definitions I</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>05: Declarations and definitions I</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">November 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../../cs/posts/05_deklarace_a_definice_I.html">Česká verze</a> <span class="image"><a class="image" href="../../cs/posts/05_deklarace_a_definice_I.html"><img src="https://www.countryflags.io/cz/shiny/24.png" alt="Česká verze"></a></span><br>
<a href="../index.html">Homepage</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>If you think it&#8217;s simple, then you have misunderstood the problem.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bjarne Stroustrup
</div>
</div>
<div class="paragraph">
<p>Assume that&#8201;&#8212;&#8201;<strong>somewhere in the void</strong>&#8201;&#8212;&#8201;there exist the following function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int a, int b)
{
  return a + b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let us now try to write a source file for a program that <strong>uses this function</strong>. The first attempt may look like:</p>
</div>
<div class="listingblock">
<div class="title">main.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we now try to <strong>generate machine code</strong> for this source code (for example, by running <code>g++ -O2 -c main.cpp</code>), it <strong>fails</strong>. Why?</p>
</div>
<div class="paragraph">
<p>In the source code, the <code>add</code> function is <strong>called</strong> from the <code>main</code> function. Therefore, a compiler needs to generate a corresponding call of <code>add</code> at the machine code level. On an x86_64 architecture, such a call is represented by the <code>call</code> instruction. But this instruction, alone, is <strong>not sufficient</strong>.</p>
</div>
<div class="paragraph">
<p>A compiler also needs to generate instructions for <strong>passing arguments and a return value to/from the function</strong>. In our case, a compiler “sees” the arguments (<code>i</code> and <code>2</code>, both of type <code>int</code>), and also sees what is done with the return value (application of the binary operator <code>+</code>). However, this is <strong>not enough</strong> for the generation of corresponding “passing instructions”. For example&#8201;&#8212;&#8201;are the arguments passed by value of by reference? Or, is there any implicit conversion required? At a machine code level, this makes a difference.</p>
</div>
<div class="paragraph">
<p>What is missing here for a successful generation of passing instructions is that a compiler also needs to see <strong>the types of function parameters as well as its return type</strong>. The provision of such information is the role of a <strong>function declaration</strong>. In our case, the simplest form of the declaration of the function <code>add</code> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int, int);</code></pre>
</div>
</div>
<div class="paragraph">
<p>How to assure that our compiler will <strong>see this declaration</strong> when compiling <code>main</code>? The most fundamental solution is simply to add it into the same source file:</p>
</div>
<div class="listingblock">
<div class="title">main2.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, the compilation with <code>g++ -O2 -c main2.cpp</code> succeeds, and, in my case, I obtained the following instructions for the <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">sub  rsp, 8
mov  esi, 2
mov  edi, 1
call add(int, int)
add  rsp, 8
add  eax, 3
ret</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Application binary interface (ABI)</div>
<div class="paragraph">
<p>On each computer system, there needs to be some <strong>agreement</strong> on how to pass arguments and return values to/from functions <strong>at a machine code level</strong>. This agreement is a part of what is called an <strong>application binary interface (ABI)</strong>. Without an ABI, pieces of machine code generated, for example, by different compilers would not be able to cooperate.</p>
</div>
<div class="paragraph">
<p>On my system, the ABI prescribes that the values of arguments are&#8201;&#8212;&#8201;into a function having two parameters of type <code>int</code>&#8201;&#8212;&#8201;passed through the <code>edi</code> and <code>esi</code> registers, respectively. Since, in my <code>add</code> function call, the arguments have values 1 and 2, they are assigned to these registers.
The applied ABI also prescribes that the return value of type <code>int</code> is passed from a function through the <code>eax</code> register. Note that in our case, this holds for both the <code>add</code> and <code>main</code> functions. According to the source code, the value returned from <code>add</code> is incremented by 3 and then returned from <code>main</code>. At a machine code level, a simple increment of <code>eax</code> by 3 therefore renders this effect.</p>
</div>
<div class="paragraph">
<p>Finally, why are there those two instructions that manipulate the <em>stack pointer</em> register <code>rsp</code>? It is again related to the applied ABI. Namely, the ABI prescribes that, at the beginning of execution of some function, a part of the stack available to it&#8201;&#8212;&#8201;the so-called <em>stack frame</em>&#8201;&#8212;&#8201;which is pointed to by <code>rsp</code>, shall be aligned to a 16-byte address.</p>
</div>
<div class="paragraph">
<p>At the beginning of <code>main</code>, the address stored in <code>rsp</code> is therefore aligned to a 16-byte memory boundary. However, the subsequent <code>call</code> instruction stores, on the stack, the current value of the <em>instruction pointer</em> <code>rip</code>. This is necessary such that the <code>ret</code> instruction called within the <code>add</code> function knows where to go back.</p>
</div>
<div class="paragraph">
<p>This “remembering” of <code>rip</code> on the stack involves decrementing <code>rsp</code> by 8. To ensure the 16-byte alignment of the stack frame at the beginning of <code>add</code>, <code>rsp</code> therefore needs to be decremented by 8 once more, which is accomplished by that <code>sub rsp, 8</code> instruction. After the <code>add</code> function call, the effect of this operation is reverted by <code>add rsp, 8</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Now, we are able to compile (translate) the source code of <code>main2.cpp</code> into machine code. However, this machine code is <strong>not yet in the form an executable program</strong>. Instead, thanks to the <code>-c</code> command line option provided to <code>g++</code>, it has the form of the so-called <strong>object file</strong>, which has the <code>main2.o</code> filename by default.</p>
</div>
<div class="paragraph">
<p>To build an executable program, all occurrences of the <code>call</code> instruction needs to be <strong>linked</strong> to the machine code of the corresponding functions. This is a task for a C&#43;&#43; implementation tool called a <strong>linker</strong>. In my case, the linker is a program called <code>ld</code>, which is internally used by <code>g++</code> when this gets an object file as an input.</p>
</div>
<div class="paragraph">
<p>With my <code>g&#43;&#43;</code>-based implementation, we now have <strong>two options</strong> for building an executable program from <code>main2.cpp</code>. The first one is to <strong>separately compile</strong> this source file with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="plaintext" class="language-plaintext hljs">g++ -O2 -c main2.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the resulting <code>main2.o</code> object file <strong>link</strong> into an executable program with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="plaintext" class="language-plaintext hljs">g++ main2.o</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second option is to <strong>merge both steps into a single command</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="plaintext" class="language-plaintext hljs">g++ -O2 main2.cpp</code></pre>
</div>
</div>
<div class="paragraph">
<p>which internally <strong>does the same</strong> (only without explicit storage of <code>main2.o</code>).</p>
</div>
<div class="paragraph">
<p>In my case, both these options resulted in the following <strong>error</strong> reported by the <code>ld</code> linker:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="plaintext" class="language-plaintext hljs">undefined reference to `add(int, int)'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The cause of this error is pretty obvious&#8201;&#8212;&#8201;the linker sees the <code>call</code> instruction for the <code>add</code> function, but it does not see any machine code of this function to which it could <strong>link that call</strong>.</p>
</div>
<div class="paragraph">
<p>How to provide such machine code? Of course, a compiler cannot generate it merely from the <code>add</code> function declaration. Instead, it needs to see the <strong>body of the function</strong>, which is provided by the <strong>function definition</strong>. In our case, this definition is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int a, int b)
{
  return a + b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generally, a function definition <strong>instructs a compiler to generate its machine code</strong>. Let us, first, put the definition of <code>add</code> into a separate source file:</p>
</div>
<div class="listingblock">
<div class="title">add.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int a, int b)
{
  return a + b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we can generate its machine code in the form of the object file <code>add.o</code> with the command <code>g++ -O2 -c add.cpp</code>. The generated instructions of the <code>add</code> function were, in my case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">lea eax, [rdi+rsi]
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>lea</code> instruction adds the values of the arguments&#8201;&#8212;&#8201;passed through <code>edi</code> and <code>esi</code> (upper parts of <code>rdi</code> and <code>rsi</code> do not matter)&#8201;&#8212;&#8201;and stores the result into <code>eax</code>. This register is then used to pass the result back to the function caller.</p>
</div>
<div class="paragraph">
<p>We, finally, have all that we need to build an <strong>executable program file</strong>. In <code>main2.o</code>, there is the call of the <code>add</code> function. In <code>add.o</code>, there is its machine code. The command <code>g++ main2.o add.o</code> passes both to the linker, which then generates a program file having the <code>a.out</code> filename by default.</p>
</div>
<div class="paragraph">
<p>By the way, <code>g&#43;&#43;</code> allows us to merge the compilation of both source files and the linkage of the resulting object files into a single command: <code>g&#43;&#43; -O2 main2.cpp add.cpp</code>. In my case, the resulting executable file was the very same.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Summary</div>
<div class="ulist">
<ul>
<li>
<p>A <strong>function declaration</strong> instructs a compiler on how to <strong>generate machine code for calls of this function</strong>.</p>
</li>
<li>
<p>A <strong>function definition</strong> instructs a compiler to generate <strong>its machine code</strong> (machine code for its body).</p>
</li>
<li>
<p>For building an executable program, function call instructions <strong>need to linked</strong> with the machine code of these functions, which does a tool called a <strong>linker</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "en";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;All rights reserved.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>