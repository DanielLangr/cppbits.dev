= 03: Undefined behavior I
Daniel Langr <daniel.langr@gmail.com>
:revdate: November 2020
//:revremark: poslední modifikace říjen 2020
:rootdir: ..
include::{rootdir}/include/attributes.adoc[]
:description: If the rules of the {cpp} standard are violated, the behavior of the {cpp} implementation is not defined.

[.normal]
link:../../cs/posts/03_nedefinovane_chovani_I.html[Česká verze] image:https://www.countryflags.io/cz/shiny/24.png[Česká verze, link="../../cs/posts/03_nedefinovane_chovani_I.html"] +
link:../index.html[Homepage] image:up.png[link="../index.html"] 

''''

[quote, Bob Gray]
____
Writing in C or {cpp} is like running a chain saw with all the safety guards removed.
____

As was already mentioned, the {cpp} standard defines how a program should behave on an abstract machine according to its source code. A {cpp} implementation then guarantees the same program behavior observable on a particular computer system.

However, the {cpp} standard *does not* define program behavior *in all circumstances*. It defines the behavior only in cases where *the rules it contains are followed*. If these rules are violated, the program behavior is not defined by the standard. Such cases are called *undefined behavior (UB)*.

Undefined behavior is not related to *program runtime* only. In case that the violated rules are related to the source code *compilation*, the standard does not even define the behavior of implementations at *compile time*. Generally, undefined behavior implies that a {cpp} implementation can *behave in an arbitrary way* both at compile time and at runtime.

An example of a particular standard rule is that operations with *signed integer types* shall not *overflow*. Such overflow, therefore, implies undefined behavior:

.main.cpp
[source]
----
#include <limits>

int main()
{
  int i = std::numeric_limits<int>::max();
  i++;
  return i;
}
----

This source code can yield undefined behavior *already at compile time* since, due to optimizations, the problematic increment may be evaluated by a compiler. On the contrary, the following source code:

[source]
----
#include <iostream>
#include <limits>

int main()
{
  int i;
  std::cin >> i;
  i++;
  return i;
}
----

will cause the overflow and corresponding undefined behavior only if the value obtained from the standard input is the maximum value of the `int` type. The standard rules violation cannot happen here until that value is obtained, which happens *at runtime*.

The frequently-asked question is *what does actually happen* if the behavior is undefined. Let us get back to the `main.cpp` source code. In my case, its compilation with `g++ -O2 main.cpp` resulted in the executable program with the following machine code instructions:

[source,x86asm]
----
mov eax, -2147483648
ret
----

Is the behavior of this program *at a machine code level* undefined? Not at all. The instructions clearly *do define its behavior* -- a normal program termination with exit status -2147483648. The program thus has defined behavior, but in this case, it was *defined by the implementation*. From the perspective of the {cpp} standard, its behavior remains undefined.

.Undefined behavior and portability
****
Undefined behavior at a level of the {cpp} standard implies the *non-portability of the corresponding source code*. Indeed, the program behavior may be defined by the {cpp} implementation, but the standard does not say which behavior it should be. Different implementations can then generate programs *with very different behavior*.
****

Let us look at another example:

.main2.cpp
[source]
----
int main()
{
  float f = 0.0f;
  int* pi = reinterpret_cast<int*>(&f);
  return *pi;
}
----

`reinterpret_cast` allows us to look at the *memory representation* of an object of some type as if it actually was a memory representation of an object of some *other type*. In our case, we want to find out what is the value of an `int` object that has the *same memory representation* as a `float` object with zero value.

The problem with this code is that the {cpp} standard allows `reinterpret_cast` to be used only in a *very limited and specified number of cases*, and our case *is not* among them. Thanks to that, the behavior for this code is undefined by the standard. However, what about the implementation? By compiling this source code with `g++ -O2 main2.cpp`, I got the program with the following instructions:

[source,x86asm]
----
xor eax, eax
ret
----

It is obvious that its behavior is, again, clearly defined (normal program termination with exit status 0).

The question is whether it is guaranteed that the generated program will behave in this way. Of course, the {cpp} standard does not guarantee that. An implementation *may or may not* guarantee that, and to find out the exact answer can be complicated or even almost impossible. The good news is that implementations mostly (if not always) behave *in a deterministic way*. It is therefore highly probable that, in our case, `g++` would always produce the executable program with the same described behavior (under the same build configuration).

In some cases, {cpp} implementations even *explicitly* define program behavior even if it is undefined by the standard. Let us try to solve the same problem -- inspecting the value of an object of some type through the memory representation of an object of some other type -- with the help of the `union` class type. In contrast to `class` and `struct`, `union` stores its member variables *not next to each other, but over each other* instead. An alternative solution to `main2.cpp` could then look like:

.main3.cpp
[source]
----
union U
{
  float f;
  int i;
};

int main()
{
  U u;
  u.f = 0.0f;
  return u.i;
}
----

The member variables `f` and `i` of `u` are stored *at the same address* -- their memory representations overlap. By writing one variable and reading the other, we can seemingly solve the problem. However, the {cpp} standard *does not allow* such use of a `union` object. It allows only *reading the so-called _active_ member variable*, which is the one that has been *least recently written*. This rule is violated in our case since after writing into `u.f`, `u.i` is read.

Yet, the compilation with `g++ -O2 main3.cpp` resulted in a program with defined behavior at a machine code level:

[source,x86asm]
----
xor eax, eax
ret
----

In this case, this behavior was even *explicitly guaranteed by the implementation*. The documentation of GCC defines behavior even for cases of *reading an inactive `union` member variable* (see, for example, link:https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type-punning[]). This represents a *“non-standard” extension of the {cpp} language*.

Another example of undefined behavior “tolerated” in practice may be the effort of implementing the `std::vector<T>` container from the {cpp} standard library (this example is a bit advanced). A vector represents a dynamic array of elements of type `T`. For efficiency reasons, a vector manages *a memory allocated for some number of elements*, but the actual number of stored elements may be lower. (This concept guarantees the *amortized constant complexity* of the frequently-used operation of *adding a new element at the end of the vector*).

Let us suppose that the allocated memory is pointed to by a vector member variable `data_` of type `T*`. An allocation for `n` elements could then look like:

[source]
----
data_ = (T*)::operator new(n * sizeof(T));
----

.Allocators and allocation functions
****
`std::vector` actually performs allocations by *using an allocator* with the type of the vector second template argument. The *default value* of this allocator type for `std::vector<T>` is `std::allocator<T>`. An allocation with an allocater of this type is *effectively equivalent* to the above-shown allocation with `operator new`.

`::operator new` represents a *{cpp} allocation function* for a dynamic allocation of a block of *uninitialized memory* having a requested amount of bytes. If you are not familiar with this function, for the sake of this article, imagine a `malloc` function call instead.
****

In the allocated memory block, pointed to by the `data_` pointer, *vector elements are then constructed* (how this is done will be explained in some future article). For *accessing these elements*, there is the *indexing operator* defined, typically in the following way:

[source]
----
T& operator[](size_type n) { return data_ + n; }
----

And now there is a problem. This operator contains **pointer arithmetic for a pointer of type `T*`**. Such an operation is allowed by the {cpp} standard when being performed over an *array of objects of type `T`*. But what we have is a *block of uninitialized memory* with subsequently *constructed objects of type `T`*. According to the {cpp} standard, this *is not an array of type `T`*. The pointer arithmetic then results in undefined behavior.

.Is `std::vector` implementable?
****
We ended up with a *paradox* -- the standard prescribes how a vector should behave, but, at the same time, an effort of its implementation *almost inevitably leads to undefined behavior*. There have been many discussions about this problem. The good news is that {cpp} implementations know about it well and *provide a correct vector behavior even above the standard level*.

This problem also has been addressed by the _proposal_ document P0593R6, available here: link:http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0593r6.html[]. This proposal should be a part of the {cpp}20 standard (not yet officially published in the time of writing this article).
****

.Summary
****
- Undefined behavior is caused by *violating the rules of the {cpp} standard*.
- In the case of undefined behavior, the {cpp} standard *does not prescribe* how a {cpp} implementation should behave for a corresponding source code. An implementation can then behave *in any arbitrary way*, which holds both for *compile time* and *runtime*.
- Implementations typically behave *in a deterministic way* in such cases. Typically, they generate a program with the behavior *defined by its machine code*.
- Undefined behavior generally leads to the *non-portable source code* -- *different implementations* can behave *differently* for it.
- In some cases, {cpp} implementations *explicitly define behavior* even if it is undefined by the standard.
****

include::{rootdir}/include/disqus.adoc[]
include::{rootdir}/include/copyright.adoc[]
