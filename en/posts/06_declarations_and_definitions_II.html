<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="If a compiler sees call expression and definition of a function at once, it can generate more optimized machine code.">
<meta name="author" content="Daniel Langr">
<meta name="copyright" content="(C) Daniel Langr 2020">
<link rel="icon" type="image/png" href="../../favicon/favicon.png">
<title>06: Declarations and definitions II</title>
<link rel="stylesheet" href="../../stylesheets/ubuntu-custom.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-180949618-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-180949618-1');
</script>
</head>
<body class="article">
<div id="header">
<h1>06: Declarations and definitions II</h1>
<div class="details">
<span id="author" class="author">Daniel Langr</span><br>
<span id="email" class="email"><a href="mailto:daniel.langr@gmail.com">daniel.langr@gmail.com</a></span><br>
<span id="revdate">November 2020</span>
</div>
</div>
<div id="content">
<div class="paragraph normal">
<p><a href="../index.html">Homepage</a> <span class="image"><a class="image" href="../index.html"><img src="../../images/up.png" alt="up"></a></span></p>
</div>
<hr>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>If you think it&#8217;s simple, then you have misunderstood the problem.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Bjarne Stroustrup
</div>
</div>
<div class="paragraph">
<p>Last time, we ended up with a program built from these <strong>two source files</strong>:</p>
</div>
<div class="listingblock">
<div class="title">main2.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">add.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int a, int b)
{
  return a + b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One of these files included the <strong>declaration</strong> of the <code>add</code> function plus its use (call), while the other included its <strong>definition</strong>. Of course, we could have also inserted this definition into the file with <code>main</code>, such as follows:</p>
</div>
<div class="listingblock">
<div class="title">main3.cpp</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c++" class="language-c++ hljs">int add(int, int);

int main()
{
  int i = 1;
  int j = add(i, 2) + 3;
  return j;
}

int add(int a, int b)
{
  return a + b;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Is there any difference</strong> between these two alternatives? The source code of both is <strong>exactly the same</strong>. Moreover, the same is also their <strong>observable behavior</strong>, which is the normal program termination with exit status 6. We may easily see it, but we are not important. What matters is <strong>whether it can be “seen” by a compiler</strong>?</p>
</div>
<div class="paragraph">
<p>For the <strong>second alternative</strong>, the answer is <strong>yes</strong>. A compiler can see all the code at once; therefore, it can derive its observable behavior and render it efficiently at a machine code level. For instance, with <code>g&#43;&#43; -O2 main3.cpp</code>, I got this minimal machine code for the <code>main</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">mov eax, 6
ret</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Inlining</div>
<div class="paragraph">
<p>One of the important compiler optimization techniques is function <strong>inlining</strong>. It works such that a call of a function is <strong>virtually replaced</strong> by its body. In our case, <code>int j = add(i, 2) + 3;</code> is virtually replaced by <code>int j = (i + 2) + 3;</code>.</p>
</div>
<div class="paragraph">
<p>Note that inlining has <strong>no relation</strong> to the <code>inline</code> specifier, which is kind-of misleading for beginners. There is no <code>inline</code> specifier in our code, and yet, <code>g&#43;&#43;</code> applied inlining under the <code>-O2</code> optimization option. <code>g++</code> also allows us to explicitly disable inlining with the <code>-fno-inline</code> command-line option. With <code>g&#43;&#43; -O2 -fno-inline main3.cpp</code>, we can generate a program that contains the machine code of the <code>add</code> function and its call from within <code>main</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Let us now get back to the <strong>first alternative</strong> with two separate source files. Here, when compiling <code>main2.cpp</code>, a compiler sees the <code>add</code> function declaration plus its call, but does not know what the function performs in its body. Therefore, it has <strong>no other option</strong> than to generate a machine code with that call:</p>
</div>
<div class="listingblock">
<div class="title">main2.o</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">sub  rsp, 8
mov  esi, 2
mov  edi, 1
call add(int, int)
add  rsp, 8
add  eax, 3
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, when compiling <code>add.cpp</code>, a compiler sees the definition of the <code>add</code> function, but has no clue of how this function is used. It has only <strong>one option</strong>&#8201;&#8212;&#8201;to generate the function machine code:</p>
</div>
<div class="listingblock">
<div class="title">add.o</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="x86asm" class="language-x86asm hljs">lea eax, [rdi+rsi]
ret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, a linker only <strong>merges both pieces of machine code together</strong> into an executable program file.</p>
</div>
<div class="paragraph">
<p>Comparing both alternatives, we ended up with <strong>two executable programs</strong> that both have the very same observable behavior. However, this behavior is, in both cases, <strong>rendered very differently</strong> at a machine code level. And, we do not have to be rocket scientists to guess which of these alternatives will be more efficient at runtime. Just in terms of instruction counts, the final score is 9–2.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Link-time optimizations (LTO)</div>
<div class="paragraph">
<p>Inlining and other optimizations may be applied not only by a compiler. In theory, a linker may apply them&#8201;&#8212;&#8201;at a machine code level&#8201;&#8212;&#8201;as well. But, a linker is, well, primarily, just a linker. And, generally, optimizations are much easier to carry on when source code is available.</p>
</div>
<div class="paragraph">
<p>For example, the build tools related to both GCC and Clang enable <strong>link-time optimizations (LTO)</strong>. However, for their application, some additional information&#8201;&#8212;&#8201;so-called <em>intermediate representation</em>&#8201;&#8212;&#8201;needs to be generated by a compiler and passed to a linker.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The question of whether the difference between the above-introduced alternatives matters <strong>cannot be generally answered</strong>. Usually, when a function performs <strong>a lot of operations</strong>, the effect of its inlining on the runtime performance will be negligible. The same will likely hold for a function that is called, at runtime, <strong>only few times or even once</strong>. Generally, inlining may be noticeable for <strong>“short” functions that are called frequently</strong>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Summary</div>
<div class="ulist">
<ul>
<li>
<p>A compiler may generate much more optimized machine code, if it “sees” <strong>both the function call and the definition of that function</strong> at the same time.</p>
</li>
<li>
<p>The application of function inlining <strong>is not related</strong> to the <code>inline</code> specifier.</p>
</li>
<li>
<p>Inlining is especially important for <strong>frequently-called functions that perform only few operations</strong>.</p>
</li>
</ul>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = window.location.href;
this.page.identifier = window.location.pathname;
this.language = "en";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://yact.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<div class="sidebarblock">
<div class="content">
<div class="paragraph text-center">
<p>&#169; 2020 Daniel Langr&#8201;&#8212;&#8201;All rights reserved.</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/agate.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>